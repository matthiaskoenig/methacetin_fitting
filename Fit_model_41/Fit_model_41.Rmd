---
title: "Fitting model 39"
output: 
  html_document:
    toc: TRUE
---


Load all important libraries
```{r setup, message=FALSE, warning=FALSE, eval=TRUE, echo=FALSE}
knitr::opts_chunk$set(eval = TRUE)
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(fig.height = 10)
knitr::opts_chunk$set(fig.width = 15)
library(dMod)
library(stringr) # Um bequem mit strings zu arbeiten
library(tidyverse) # Viele Funktionen, u.a. für data.frames und ggplot2 für schöne plots
library(magrittr) # der Pipe-operator %>%: z.B: x =" a; y="f(x); z="g(y); wird zu z=" a %>% f %>% g
library(conveniencefunctions)



# load("2018_03_09_17_17_workspace.rda")
# for(i in lsdMod(classlist = "prdfn")) {loadDLL(i)}
```


# Read model
```{r}
source("../model/limax_pkpd_v41.R")
```


```{r}
pars_raw <- c(x0, p) 
pars_in_dxdtdmod <- c(getSymbols(dxdt_dmod), names(dxdt_dmod))
```

# Odemodels and predicition function

## Apap
```{r odemodel_apap}
free_pars_apap <- c("Ka_apap", "APAPD_HLM_CL", "APAPD_Km_apap")
odemodel_apap <- odemodel(dxdt_dmod, modelname = "odemodel_apap", fixed = setdiff(pars_in_dxdtdmod, c(free_pars_apap, "Aar_apap"))) # Aar_apap is not there to be optimized, but a variable which is a state is needed because of a bug in odemodel.

x_apap <- Xs(odemodel_apap)
```


## Bicarbonate

```{r odemodel_bic}
free_pars_bic <- c("Ka_co2c13", "KLU_EXCO2", "CO2FIX_HLM_CL", "KBO_FIXCO2", "KBO_RELCO2", "KBO_MAXCO2")
odemodel_bic <- odemodel(dxdt_dmod, modelname = "odemodel_bic", fixed = setdiff(pars_in_dxdtdmod, c(free_pars_bic, "Aar_apap"))) # Aar_apap is not there to be optimized, but a variable which is a state is needed because of a bug in odemodel.

x_bic <- Xs(odemodel_bic)
```

## Metc13

```{r odemodel_met}
free_pars_met <- c("Ka_metc13", "CYP1A2MET_CL", "CYP1A2MET_Km_met")
odemodel_met <- odemodel(dxdt_dmod, modelname = "odemodel_met", fixed = setdiff(pars_in_dxdtdmod, c(free_pars_met, "Aar_apap"))) # Aar_apap is not there to be optimized, but a variable which is a state is needed because of a bug in odemodel.

x_met <- Xs(odemodel_met)
```


# Observation functions

## Apap

```{r g_apap}
observables_apap <- y_dmod[c("Mve_apap")] %>% set_names(c("Mve_apap"))
g_apap <- Y(g = observables_apap, f = x_apap, attach.input = F, modelname = "g_apap", compile = F)
```

## Bicarbonate

```{r g_bic}
recovery_bic <- paste(y_dmod["Exhalation_co2c13"], "/ 60 * Mr_co2c13 / Ri_co2c13 * 100")
observables_bic <- c(recovery_bic, y_dmod[c("DOB", "P_CO2Fc13")])
names(observables_bic) <- c("cum_rec_co2c13", "DOB", "P_CO2F")

observables_bic["P_CO2F"] <- paste0(observables_bic["P_CO2F"], " + offset_bic")

g_bic <- Y(observables_bic, x_bic, attach.input = F, modelname = "g_bic", compile = F)
```

## Metc13

```{r g_met}
recovery_met <- paste(y_dmod["Exhalation_co2c13"], "/ init_PODOSE_metc13 * Mr_metc13 * 100" )
cum_met <- paste( "Abreath_co2c13/ init_PODOSE_metc13 * Mr_metc13 * 100")
observables_met <- c(recovery_met, cum_met) %>% set_names(c("mom_rec_metc13", "cum_rec_metc13"))

g_met <- Y(observables_met, x_met, attach.input = F, modelname = "g_met", compile = F)
```



# Data - read and preprocess
Read data, insert the default values for the parameters supplied in the data sheet. 

* Taheri rausschmeißen zum Fitten: Wird weiter unten getan

```{r, message=FALSE}
data <-
  read_tsv("../data/limax_pkpd_v41_data.csv") %>%
  select(-model) %>% 
  rename(name = observer) %>% 
  rename(n = subjects) %>% 
  unique() #noch matthias sagen, dass lalazar2008 doppelte einträge hat


fitErrorModel_factors <- c("study", "group", "name", "BW", "PODOSE_apap", "IVDOSE_apap", 
"PODOSE_co2c13", "IVDOSE_co2c13", "Ri_co2c13", "ti_co2c13", "PODOSE_metc13", 
"IVDOSE_metc13", "ti_metc13")
some_na <- 
  data %>% 
  group_by(study, group, name) %>% 
  mutate(nna = n(), sna = sum(is.na(sigma))) %>% 
  filter(sna>0 & sna != nna) %>% 
  select(-sna, -nna) %>% 
  as.data.frame() %>% 
  fitErrorModel(factors = fitErrorModel_factors, plotting = F)

none_or_all_na <- data %>% 
  group_by(study, group, name) %>% 
  mutate(nna = n(), sna = sum(is.na(sigma))) %>% 
  filter(sna==0 | sna == nna) %>% 
  select(-sna, -nna) %>% 
  as.data.frame()

data <- rbind(some_na, none_or_all_na) %>% 
  select(-n)


supplied_pars <- names(pars_raw)[(names(pars_raw) %in% names(data))]
```


# Parameter trafos
## Apap
```{r p_apap}
data_apap <- data %>%  
  filter(simulation == "apap") %>% 
  select(-simulation) %>% 
  as.data.frame()
  
outer_pars_apap <- sort(c(supplied_pars, free_pars_apap))

trafo_apap <-
  pars_raw %>% 
  sort_by_name() %>% 
  replace((names(.) %in% outer_pars_apap), outer_pars_apap) %>% 
  
  branch(data_apap %>% as.datalist() %>% covariates()) %>% 
  
  minsert(supplied_pars) %>% 
  
  insert("x~exp(X)", x = free_pars_apap, X = toupper(free_pars_apap)) # backtrafo to linear pars from log-pars

p_apap <- P(trafo_apap, modelname = "p_apap", compile = F)

pars_apap <- log(pars_raw[free_pars_apap]) %>% set_names(toupper(free_pars_apap))

compile(g_apap, p_apap, output = "apap")

```

### Test plot
```{r plot_apap, eval=TRUE}
# loadDLL(x_apap)
times <- seq(0,24, 0.1)
plotCombined((g_apap*x_apap*p_apap)(times, pars_apap, deriv = F), data = data_apap %>% as.datalist(), name %in% names(observables_apap))

obj <- normL2(data_apap %>% as.datalist, (g_apap*x_apap*p_apap))
obj(getParameters(obj) %>% are_names_of(0))
```

## Bicarbonate

Some studies don't have sigmas. Estimate the errors for them while fitting. For this, we need to define an error model.
1. Split the data into studies a) with errors "_bic" and b) without errors "_bic_sigma_NA"
2. Define the error model (technically, this will also be an observation function: It "observes" the outputs of the model, e.g. "recovery", and calculates another variable from it, the error)
3. For both sets of data, "_bic", and "bic_sigma_NA", we now need condition specific parameters. Additionally, in "_bic_sigma_NA", we need to supply the parameters of our error model.

### Error model

```{r e_bic}
data_bic <- data %>% 
  filter(simulation == "bicarbonate")%>% 
  select(-simulation) %>% 
  as.data.frame()

studies_with_sigma_na <- data_bic %>% filter(is.na(sigma)) %>% .[["study"]] %>% unique
data_bic_sigma_NA <- data_bic %>% filter(study %in% studies_with_sigma_na)
data_bic <- data_bic %>% filter(! study %in% studies_with_sigma_na)

data_bic_sigma_NA$name %>% unique()

errors_bic_sigma_NA <- paste0("sqrt(s0_", names(observables_bic), "^2 + srel_", names(observables_bic), "^2 * ", names(observables_bic), "^2 )") %>% set_names(names(observables_bic))
errors_bic_sigma_NA["cum_rec_co2c13"] <- 1 #hierfür gibts eh keine daten und ich weiß nicht, ob ich es einfach weglassen kann

e_bic_sigma_NA <- Y(g = errors_bic_sigma_NA, f= (g_bic))
```

### Parameter trafo
```{r p_bic}
outer_pars_bic <- sort(c(supplied_pars, free_pars_bic))

trafo_bic<-
  c(pars_raw) %>% 
  sort_by_name() %>% 
  replace((names(.) %in% outer_pars_bic), outer_pars_bic) %>% 
  
  branch(data_bic %>% as.datalist() %>% covariates()) %>% # The table of covariates includes dosepar and dose, which are used in the next line
  
  minsert(supplied_pars) %>% 

  insert("x~exp(X)", x = getSymbols(mytrafo[[i]]), X = toupper(getSymbols(mytrafo[[i]]))) %>% 
  
  define("x~x", x = "offset_bic")

p_bic <- P(trafo_bic, modelname = "p_bic", compile = F)

pars_bic <- getParameters(p_bic) %>% are_names_of(0)
```

```{r p_bic_sigma_NA}
pars_errors_bic_sigma_NA <- getSymbols(errors_bic_sigma_NA) %>% str_subset("^s") %>% are_names_of(1)

outer_pars_bic <- sort(c(supplied_pars, free_pars_bic, names(pars_errors_bic_sigma_NA)))

trafo_bic_sigma_NA <-
  c(pars_raw, pars_errors_bic_sigma_NA) %>% 
  sort_by_name() %>% 
  replace((names(.) %in% outer_pars_bic), outer_pars_bic) %>% 
  
  branch(data_bic_sigma_NA %>% as.datalist() %>% covariates()) %>% # The table of covariates includes dosepar and dose, which are used in the next line
  
  minsert(supplied_pars) %>% 
  
  insert("x~exp(X)", x = getSymbols(mytrafo[[i]]), X = toupper(getSymbols(mytrafo[[i]]))) %>% 
  
  define("x~x", x = "offset_bic")

p_bic_sigma_NA <- P(trafo_bic_sigma_NA, modelname = "p_bic_sig", compile = F)

pars_bic_sigma_NA <- getParameters(p_bic_sigma_NA) %>% are_names_of(0)

# p_bic_sigma_NA(pars_bic_sigma_NA)

compile(g_bic, p_bic, p_bic_sigma_NA, output = "bic")
```


### Example plot
```{r}
loadDLL(x_bic)
(g_bic*x_bic*p_bic_sigma_NA)(times*10, pars_bic_sigma_NA, deriv = F) %>%  plotPrediction(name %in% names(observables_bic))
(g_bic*x_bic*p_bic)(times*10, pars_bic, deriv = F) %>%  
  # lapply(. %>% as.tibble)
  plotPrediction(name %in% names(observables_bic))
# obj <- normL2(data_bic %>% as.datalist,(g_bic*x_bic*p_bic))

```


## Metc13

The same game for the data sets without sigmas applies here. Read the description for Bic.

### Error model
```{r e_met}
data_met <- data %>% 
  filter(simulation == "methacetin")%>% 
  select(-simulation) %>% 
  as.data.frame()

studies_with_sigma_na <- data_met %>% filter(is.na(sigma)) %>% .[["study"]] %>% unique
data_met_sigma_NA <- data_met %>% filter(study %in% studies_with_sigma_na)
data_met <- data_met %>% filter(! study %in% studies_with_sigma_na)

errors_met_sigma_NA <- paste0("sqrt(s0_", names(observables_met), "^2 + srel_", names(observables_met), "^2 * ", names(observables_met), "^2)") %>% set_names(names(observables_met))
errors_met_sigma_NA["mom_rec_metc13"] <- 1 #hierfür gibts eh keine daten mit sigma=NA

e_met_sigma_NA <- Y(g = errors_met_sigma_NA, f= (g_met))


```

### Parameter trafo
```{r p_met}
outer_pars_met <- sort(c(supplied_pars, free_pars_met))

trafo_met<-
  c(pars_raw) %>% 
  sort_by_name() %>% 
  replace((names(.) %in% outer_pars_met), outer_pars_met) %>% 
  
  branch(data_met %>% as.datalist() %>% covariates()) %>%  # The table of covariates includes dosepar and dose, which are used in the next line
  
  minsert(supplied_pars) %>% 

  define("init_PODOSE_metc13~podose", podose = mytrafo[[i]]["PODOSE_metc13"]) %>% # For the observables, I need the initial dose as a fixed parameter which doesn't change. Because the PODOSE_metc13 is also a state, I need to duplicate this parameters
    
  insert("x~exp(X)", x = getSymbols(mytrafo[[i]]), X = toupper(getSymbols(mytrafo[[i]]))) 

p_met <- P(trafo_met, modelname = "p_met", compile = F)

pars_met <- getParameters(p_met) %>% are_names_of(0)
```


```{r p_met_sigma_NA}
pars_errors_met_sigma_NA <- getSymbols(errors_met_sigma_NA) %>% str_subset("^s") %>%  are_names_of(1)

outer_pars_met <- sort(c(supplied_pars, free_pars_met, names(pars_errors_met_sigma_NA)))

trafo_met_sigma_NA <-
  c(pars_raw, pars_errors_met_sigma_NA) %>% 
  sort_by_name() %>% 
  replace((names(.) %in% outer_pars_met), outer_pars_met) %>% 
  
  branch(data_met_sigma_NA %>% as.datalist() %>% covariates()) %>% # The table of covariates includes dosepar and dose, which are used in the next line
  
  minsert(supplied_pars) %>% 
  
  define("init_PODOSE_metc13~podose", podose = mytrafo[[i]]["PODOSE_metc13"]) %>% # For the observables, I need the initial dose as a fixed parameter which doesn't change. Because the PODOSE_metc13 is also a state, I need to duplicate this parameters
  
  insert("x~exp(X)", x = getSymbols(mytrafo[[i]]), X = toupper(getSymbols(mytrafo[[i]])))



p_met_sigma_NA <- P(trafo_met_sigma_NA, modelname = "p_met_sig", compile = F)

pars_met_sigma_NA <- getParameters(p_met_sigma_NA) %>% are_names_of(0)

compile(g_met, p_met, p_met_sigma_NA, output = "met")
```

### Example plot
```{r}
loadDLL(x_met)
(g_met*x_met*p_met_sigma_NA)(times*100, pars_met_sigma_NA, deriv = F) %>% plotPrediction(name %in% names(observables_met))
```



# Bic and met together
```{r x, g and e bicmet}
free_pars_bicmet <- c(free_pars_bic, free_pars_met)
odemodel_bicmet <- odemodel(dxdt_dmod, modelname = "odemodel_bicmet", fixed = setdiff(pars_in_dxdtdmod, c(free_pars_bicmet, "Aar_apap"))) # Aar_apap is not there to be optimized, but a variable which is a state is needed because of a bug in odemodel.
x_bicmet <- Xs(odemodel_bicmet)

g_bicmet <- Y(c(observables_bic, observables_met), x_bicmet, attach.input = F, modelname = "g_bicmet", compile = F)

e_bicmet <- Y(c(errors_bic_sigma_NA, errors_met_sigma_NA), g_bicmet)# , modelname = "e_bicmet", compile = F)
```

```{r data and p bicmet}
data_bicmet <- rbind(data_bic, data_met)
data_bicmet_sigma_NA <- rbind(data_bic_sigma_NA, data_met_sigma_NA)

outer_pars_bic <- sort(c(supplied_pars, free_pars_bic))
outer_pars_bic_sigma_NA <- sort(c(supplied_pars, free_pars_bic, names(pars_errors_bic_sigma_NA)))

outer_pars_met <- sort(c(supplied_pars, free_pars_met))
outer_pars_met_sigma_NA <- sort(c(supplied_pars, free_pars_met, names(pars_errors_met_sigma_NA)))

trafo_bicmet<-
  c(pars_raw) %>% 
  sort_by_name() %>% 
  replace((names(.) %in% unique(c(outer_pars_bic, outer_pars_met))), sort(unique(c(outer_pars_bic, outer_pars_met)))) %>% 
  
  branch(data_bicmet %>% as.datalist() %>% covariates()) %>% # The table of covariates includes dosepar and dose, which are used in the next line
  
  minsert(supplied_pars) %>% 

  define("init_PODOSE_metc13~podose", podose = mytrafo[[i]]["PODOSE_metc13"]) %>% # For the observables, I need the initial dose as a fixed parameter which doesn't change. Because the PODOSE_metc13 is also a state, I need to duplicate this parameters

  insert("x~exp(X)", x = getSymbols(mytrafo[[i]]), X = toupper(getSymbols(mytrafo[[i]]))) %>% 
  
  define("x~x", x = "offset_bic")


trafo_bicmet_sigma_NA <-
  c(pars_raw, pars_errors_bic_sigma_NA, pars_errors_met_sigma_NA) %>% 
  sort_by_name() %>% 
  replace((names(.) %in% unique(c(outer_pars_bic_sigma_NA, outer_pars_met_sigma_NA))), sort(unique(c(outer_pars_bic_sigma_NA, outer_pars_met_sigma_NA)))) %>% 
  
  branch(data_bicmet_sigma_NA %>% as.datalist() %>% covariates()) %>% # The table of covariates includes dosepar and dose, which are used in the next line
  minsert(supplied_pars) %>% 
  #bic

  #met
  define("init_PODOSE_metc13~podose", podose = mytrafo[[i]]["PODOSE_metc13"]) %>% # For the observables, I need the initial dose as a fixed parameter which doesn't change. Because the PODOSE_metc13 is also a state, I need to duplicate this parameters

  insert("x~exp(X)", x = getSymbols(mytrafo[[i]]), X = toupper(getSymbols(mytrafo[[i]]))) %>% 
  

  define("x~x", x = "offset_bic") %>% 
  
  #met
  {.}


p_bicmet <- P(trafo_bicmet, modelname = "p_bicmet", compile = F)
pars_bicmet <- getParameters(p_bicmet) %>% are_names_of(0)

p_bicmet_sigma_NA <- P(trafo_bicmet_sigma_NA, modelname = "p_sig_bicmet", compile = F)
pars_bicmet_sigma_NA <- getParameters(p_bicmet_sigma_NA) %>% are_names_of(0)

compile(g_bicmet, p_bicmet, p_bicmet_sigma_NA, cores = 3, output = "bicmet")
```

# Apap, bic and met

```{r x, g and e apapbicmet}
free_pars_apapbicmet <- c(free_pars_apap, free_pars_bic, free_pars_met)
odemodel_apapbicmet <- odemodel(dxdt_dmod, modelname = "odemodel_apapbicmet", fixed = setdiff(pars_in_dxdtdmod, c(free_pars_apapbicmet, "Aar_apap"))) # Aar_apap is not there to be optimized, but a variable which is a state is needed because of a bug in odemodel.
x_apapbicmet <- Xs(odemodel_apapbicmet)

g_apapbicmet <- Y(c(observables_apap, observables_bic, observables_met), x_apapbicmet, attach.input = F, modelname = "g_apapbicmet", compile = F)

e_apapbicmet <- Y(c(errors_bic_sigma_NA, errors_met_sigma_NA), g_apapbicmet)#, modelname = "e_apapbicmet", compile = F) #cant cope with NaNs passed to it, if compiled
```

```{r data and p apapbicmet}
data_apapbicmet <- rbind(data_apap, data_bic, data_met)
data_apapbicmet_sigma_NA <- rbind(data_bic_sigma_NA, data_met_sigma_NA)

outer_pars_apap <- sort(c(supplied_pars,free_pars_apap))

outer_pars_bic <- sort(c(supplied_pars, free_pars_bic))
outer_pars_bic_sigma_NA <- sort(c(supplied_pars, free_pars_bic, names(pars_errors_bic_sigma_NA)))

outer_pars_met <- sort(c(supplied_pars, free_pars_met))
outer_pars_met_sigma_NA <- sort(c(supplied_pars, free_pars_met, names(pars_errors_met_sigma_NA)))

outer_pars_apapbicmet <- sort(unique(c(outer_pars_apap, outer_pars_bic, outer_pars_met)))
outer_pars_apapbicmet_sigma_NA <- sort(unique(c(outer_pars_apap, outer_pars_bic, outer_pars_bic_sigma_NA, outer_pars_met,outer_pars_met_sigma_NA)))

trafo_apapbicmet<-
  c(pars_raw) %>% 
  sort_by_name() %>% 
  replace(names(.) %in% outer_pars_apapbicmet, outer_pars_apapbicmet) %>% 
  
  branch(data_apapbicmet %>% as.datalist() %>% covariates()) %>% # The table of covariates includes dosepar and dose, which are used in the next line
  
  minsert(supplied_pars) %>% 
  
  define("init_PODOSE_metc13~podose", podose = mytrafo[[i]]["PODOSE_metc13"]) %>% # For the observables, I need the initial dose as a fixed parameter which doesn't change. Because the PODOSE_metc13 is also a state, I need to duplicate this parameters
  
  insert("x~exp(X)", x = getSymbols(mytrafo[[i]]), X = toupper(getSymbols(mytrafo[[i]]))) %>% 
  
  define("x~x", x = "offset_bic")


trafo_apapbicmet_sigma_NA <-
  c(pars_raw, pars_errors_bic_sigma_NA, pars_errors_met_sigma_NA) %>% 
  sort_by_name() %>% 
  replace(names(.) %in% outer_pars_apapbicmet_sigma_NA, outer_pars_apapbicmet_sigma_NA) %>% 
  
  branch(data_apapbicmet_sigma_NA %>% as.datalist() %>% covariates()) %>% # The table of covariates includes dosepar and dose, which are used in the next line
  minsert(supplied_pars) %>% 
  #bic

  #met
  define("init_PODOSE_metc13~podose", podose = mytrafo[[i]]["PODOSE_metc13"]) %>% # For the observables, I need the initial dose as a fixed parameter which doesn't change. Because the PODOSE_metc13 is also a state, I need to duplicate this parameters
  
  insert("x~exp(X)", x = getSymbols(mytrafo[[i]]), X = toupper(getSymbols(mytrafo[[i]]))) %>% 
  
  #bic
  define("x~x", x = "offset_bic") %>% 
  
  #met
  {.}



p_apapbicmet <- P(trafo_apapbicmet, modelname = "p_apapbicmet", compile = F)
pars_apapbicmet <- getParameters(p_apapbicmet) %>% are_names_of(0)

p_apapbicmet_sigma_NA <- P(trafo_apapbicmet_sigma_NA, modelname = "p_sig_apapbicmet", compile = F)

pars_apapbicmet_sigma_NA <- getParameters(p_apapbicmet_sigma_NA) %>% are_names_of(0)


compile(g_apapbicmet,  p_apapbicmet, p_apapbicmet_sigma_NA, cores = 3, output = "apapbicmet")
```


# dMod.frames

```{r initialize dMod.frames }
# remove(basic_hypotheses.frame, bicmet.frame, apapbicmet.frame)

basic_hypotheses.frame <- tibble(hypothesis = c("apap",  "bic", "met"),
                     x = list(x_apap,  x_bic, x_met)) %>% 
  add_column( g = list(g_apap,  g_bic, g_met)) %>% 
  add_column(p_0 = list(p_apap,  p_bic, p_met),
             data_0 = list(data_apap,  data_bic, data_met),
             p_sig = list(NULL,  p_bic_sigma_NA, p_met_sigma_NA),
             e = list(NULL,  e_bic_sigma_NA, e_met_sigma_NA),
             data_sig = list(NULL,  data_bic_sigma_NA, data_met_sigma_NA)
  )
# basic_hypotheses.frame <- basic_hypotheses.frame[1,] # keep only apap

bicmet.frame <- tibble(
  hypothesis = "bicmet",
  x = list(x_bicmet),
  g = list(g_bicmet),
  p_0 = list(p_bicmet),
  data_0 = list(data_bicmet),
  p_sig = list(p_bicmet_sigma_NA),
  e = list(e_bicmet),
  data_sig = list(data_bicmet_sigma_NA)
)

apapbicmet.frame <- tibble(
  hypothesis = "apapbicmet",
  x = list(x_apapbicmet),
  g = list(g_apapbicmet),
  p_0 = list(p_apapbicmet),
  data_0 = list(data_apapbicmet),
  p_sig = list(p_apapbicmet_sigma_NA),
  e = list(e_apapbicmet),
  data_sig = list(data_apapbicmet_sigma_NA)
)

```


# Prepare fits

```{r functions for dMod.frames to create objfuns and make them frame smaller again}
dMf_append_objfuns <- function(dMod.frame) dMod.frame %>% 
    mutate(data_0 = map(data_0, as.datalist),
         data_sig = map(data_sig, as.datalist)) %>% 
  mutate(prd_0 = map(seq_along(x), function(i) cfn(g[[i]], cfn(x[[i]],p_0[[i]]))),
         prd_sig = map(seq_along(x), function(i) cfn(g[[i]], cfn(x[[i]],p_sig[[i]])))) %>% 
  mutate(obj_0 = map(seq_along(x), function(i) normL2(data_0[[i]], prd_0[[i]])),
         obj_sig = map(seq_along(x), function(i) cf_normL2(data = data_sig[[i]], prd_sig[[i]], e = e[[i]]))) %>% 
  
  mutate(obj = map(seq_along(x), function(i) obj_sig[[i]]+obj_0[[i]])) %>% 
  mutate(prd = map(seq_along(x), function(i) prd_sig[[i]]+prd_0[[i]])) %>% 
  mutate(data= map(seq_along(x), function(i) data_sig[[i]]+data_0[[i]])) 

dMf_reduce <- function(dMod.frame) dMod.frame %>% 
  select(-contains("_0")) %>% 
  select(-contains("_sig"))
```

```{r augment dMod.frames}
basic_hypotheses.frame <- basic_hypotheses.frame %>% 
  dMf_append_objfuns()
  
bicmet.frame <- bicmet.frame%>% 
  dMf_append_objfuns()

apapbicmet.frame <- apapbicmet.frame%>% 
  dMf_append_objfuns()
```


```{r test objfuns}
basic_hypotheses.frame %>% .$obj %>% walk(loadDLL)
bicmet.frame %>% .$obj %>% walk(loadDLL)
apapbicmet.frame %>% .$obj %>% walk(loadDLL)


# basic_hypotheses.frame %>% mutate(test = map(seq_along(x), function(i) {
#   return(obj[[i]](getParameters(obj[[i]]) %>% are_names_of(0)))})
#   ) %>% .$test

bicmet.frame %>% mutate(test = map(seq_along(x), function(i) obj_sig[[i]](getParameters(obj_sig[[i]]) %>% are_names_of(0)))) %>% .$test

apapbicmet.frame%>% dMf_reduce() %>%  mutate(test = map(seq_along(x), function(i) obj[[i]](getParameters(obj[[i]]) %>% are_names_of(0)))) %>% .$test



```


```{r}
save.image(tpaste0("workspace_with_dMod.frames.rda"))
```

# Start fits
```{r load workspace up to here}
load("2018_03_31_02_21_workspace_with_dMod.frames.rda")
rbind(bicmet.frame, apapbicmet.frame) %>% .$obj %>% walk(loadDLL)
```



```{r start fits with broad sampling}
apapbicmet.frame <- apapbicmet.frame %>% dMf_reduce()

apapbicmet.frame[["pars"]] <- getParameters(apapbicmet.frame[["obj"]][[1]]) %>% are_names_of(0) %>% list

fit_apapbicmet_broad_sampling <- runbg({
  ncores <- detectFreeCores()
  assign("ncores", ncores, pos = .GlobalEnv)

  apapbicmet.frame %>%
    mutate(fits = map(seq_along(x), function(i) {
      assign("fit_obj", obj[[i]], pos = .GlobalEnv)
      assign("fit_pars", pars[[i]], pos = .GlobalEnv)
      assign("fit_studyname", paste0("fits", hypothesis[[i]]), pos = .GlobalEnv)
      mstrust(objfun = fit_obj, center = fit_pars, studyname = fit_studyname,
              sd = 4,
              blather = F, cores = ncores, fits = 15*ncores)
    }))
  }, machine = paste0("knecht", 1:5), filename = paste0("tmp_",tpaste0("fit_apapbicmet_broad_sampling")), input = "apapbicmet.frame")


bicmet.frame <- bicmet.frame %>% dMf_reduce()

bicmet.frame[["pars"]] <- getParameters(bicmet.frame[["obj"]][[1]]) %>% are_names_of(0) %>% list

fit_bicmet_broad_sampling <- runbg({
  ncores <- detectFreeCores()
  assign("ncores", ncores, pos = .GlobalEnv)
  
  bicmet.frame %>%
    mutate(fits = map(seq_along(x), function(i) {
      assign("fit_obj", obj[[i]], pos = .GlobalEnv)
      assign("fit_pars", pars[[i]], pos = .GlobalEnv)
      assign("fit_studyname", paste0("fits", hypothesis[[i]]), pos = .GlobalEnv)
      mstrust(objfun = fit_obj, center = fit_pars, studyname = fit_studyname,
              sd = 4,
              blather = F, cores = ncores, fits = 25*ncores)
    }))
}, machine = paste0("ruprecht", 1:2), filename = paste0("tmp_",tpaste0("fit_bicmet_broad_sampling")), input = "bicmet.frame")

```

```{r}
save.image(tpaste0("workspace_apapbicmet_and_bicmet_fits_started.rda"))
```



# Load and look at fits
```{r get fit results from knechte}
# load("2018_03_31_02_30_workspace_apapbicmet_and_bicmet_fits_started.rda")
# apapbicmet.frame %>% .$obj %>% walk(loadDLL)
# apapbicmet.frame[["fits"]] <- fit_apapbicmet_broad_sampling$get() %>% map("fits") %>% map(1) %>%  Reduce(c.parlist,.) %>% list()
# save.image(tpaste0("workspace_apapbicmet_with_fits.rda"))
```



```{r }
load("20")
apapbicmet.frame %>% .$obj %>% walk(loadDLL)
saveRDS(apapbicmet.frame$parframes, tpaste0("fits_apapbicmet_1.rds"))
```

```{r}
# apapbicmet.frame <- apapbicmet.frame %>% mutate(prd = map(prd, function(i) {controls(i, name = "attach.input") <- FALSE; i} ))

apapbicmet.frame <- 
  apapbicmet.frame %>% 
  dMf_expand_fits() %>% 
  dMf_append_plots()
```

no nice steps
```{r}
apapbicmet.frame$parframes %>% .[[1]] %>% .[1:800,] %>% plotValues()
```

The error-model just kills the steps, I think. Maybe I should reduce it.
Except for in Krumbiegel, it appears as if the absolute error can be kicked out
```{r}
apapbicmet.frame$parframes %>% .[[1]] %>% .[1:20,] %>% plotPars() +
  coord_cartesian(ylim = c(-5,5))
```

```{r}
apapbicmet.frame$best_parvec
```



Browsing through the conditions, one can see that met isnt met very well (haha)
```{r}
apapbicmet.frame %>% dMf_append_plots() %>% .[["plot_combined"]]

plotCombined(apapbicmet.frame[["prd"]][[1]](seq(0,24,0.1), 
                                            apapbicmet.frame$best_parvec[[1]], deriv = F),
             apapbicmet.frame[["data"]][[1]], 
             condition %in% rownames(rbind(data_bic_sigma_NA) %>% as.datalist %>% covariates()) &
               name %in% names(observables_bic)#getEquations(apapbicmet.frame[["g"]][[1]])[[1]])
             )
# ggplotly()
```

look at differences in parameters wrt the best parvec
```{r}
myparframe <- apapbicmet.frame$parframes[[1]]

myparframe[,5:27] <- myparframe[,5:27] %>% map(function(i) return(i - i[1]))

myparframe %>% .[1:10,] %>% plotPars() + 
  coord_cartesian(ylim = c(-2,2))
```


# Restart some fits

```{r}
basic_hypotheses.frame <- basic_hypotheses.frame %>% dMf_reduce()

basic_hypotheses.frame <- basic_hypotheses.frame %>% mutate(pars = map(seq_along(x), function(i)  getParameters(obj[[i]]) %>% are_names_of(0)))

fit_basic_hypotheses_broad_sampling <- runbg({
  ncores <- detectFreeCores()
  assign("ncores", ncores, pos = .GlobalEnv)

  basic_hypotheses.frame %>%
    mutate(fits = map(seq_along(x), function(i) {
      assign("fit_obj", obj[[i]], pos = .GlobalEnv)
      assign("fit_pars", pars[[i]], pos = .GlobalEnv)
      assign("fit_studyname", paste0("fits", hypothesis[[i]]), pos = .GlobalEnv)
      mstrust(objfun = fit_obj, center = fit_pars, studyname = fit_studyname,
              sd = 4,
              blather = F, cores = ncores, fits = 15*ncores)
    }))
  }, machine = paste0("knecht", 1:5), filename = paste0("tmp_",tpaste0("fit_basic_hypotheses")), input = "basic_hypotheses.frame")
```

```{r}
save.image(tpaste0("workspace_basic_hypotheses_fits_started.rda"))
```

# To do next: 

* Get the fits, compare with old results
* Start new fits with priors around the old results
* Save fits as rds in the future!

# Get old fits

```{r old fits}
old_basic.frame <- readRDS("2018_03_25_21_06_fit.frame.rds")
prior_apap <- old_basic.frame %>% dMf_expand_fits() %>% .$best_parvec %>% .[[1]]
```

```{r}
old_bicmet.frame <- readRDS("../fitting/2018_03_29_18_09_bicmet_refitted.rds")
prior_bicmet <- old_bicmet.frame%>% dMf_expand_fits() %>% .$best_parvec %>% .[[1]]
```

# Start fits with prior around old fits

```{r}
prior <- c(prior_apap, prior_bicmet) %>% .[!str_detect(names(.), "^S")]
class(prior) <- "numeric"
attr(prior, "deriv") <- NULL
dput(prior)
apapbicmet_prior.frame <- apapbicmet.frame

apapbicmet_prior.frame <- apapbicmet_prior.frame[,1:8]
apapbicmet_prior.frame[["hypothesis"]] <- "Prior around old fits"
apapbicmet_prior.frame <- map(1:4, function(i) apapbicmet_prior.frame) %>% do.call(rbind,.)
apapbicmet_prior.frame <-apapbicmet_prior.frame %>% mutate(sigma_prior = c(0.0001, 0.01, 1, 10)) %>% mutate(mu_prior = map(1:4, function(i) structure(c(0.255612598380746, 0.538956047621218, -1.44260842367156, 
-1.02673969006676, -0.686131603272496, -10.5578956723622, 4.68324578583817, 
1.65222659290464, 2.48470059603214, -3.6567384812666, -11.1322105945781, 
0.385743406722386, -0.0111086946469918), .Names = c("KA_APAP", 
"APAPD_HLM_CL", "APAPD_KM_APAP", "CO2FIX_HLM_CL", "CYP1A2MET_CL", 
"CYP1A2MET_KM_MET", "KA_CO2C13", "KA_METC13", "KBO_FIXCO2", "KBO_MAXCO2", 
"KBO_RELCO2", "KLU_EXCO2", "offset_bic")))) %>% 
  mutate(obj = map(seq_along(x), function(i) obj[[i]] + constraintL2(mu_prior[[i]], sigma = sigma_prior[[i]])))
```

```{r}
apapbicmet_prior.frame %>% mutate(test = map(seq_along(x), function(i) obj[[i]](pars[[i]]))) %>% .$test
```

```{r}
fit_apapbicmet_with_old_prior <- runbg({
  ncores <- detectFreeCores()
  assign("ncores", ncores, pos = .GlobalEnv)

  apapbicmet_prior.frame %>%
    mutate(fits = map(seq_along(x), function(i) {
      assign("fit_obj", obj[[i]], pos = .GlobalEnv)
      assign("fit_pars", pars[[i]], pos = .GlobalEnv)
      assign("fit_studyname", paste0("fits", hypothesis[[i]]), pos = .GlobalEnv)
      mstrust(objfun = fit_obj, center = fit_pars, studyname = fit_studyname,
              sd = 4,
              blather = F, cores = ncores, fits = 15*ncores)
    }))
  }, machine = paste0("knecht", 1:5), filename = paste0("tmp_",tpaste0("fit_apapbicmet_with_old_prior")), input = "apapbicmet_prior.frame")

saveRDS(fit_apapbicmet_with_old_prior, tpaste0("fit_apapbicmet_with_old_prior_started.rds"))
```


# Get new "basic" fits

```{r}
myfits <- fit_basic_hypotheses_broad_sampling$get() 

basic_hypotheses.frame[["fits"]] <- myfits %>% map("fits") %>% transpose() %>% map(function(i) Reduce(c.parlist, i))

saveRDS(basic_hypotheses.frame, tpaste0("fits_basic_hypotheses"))
```

```{r}
basic_hypotheses.frame <- basic_hypotheses.frame %>% dMf_expand_fits() %>% dMf_append_plots()
```

Was ist da los, wieso findet er Ka_apap nicht mehr bei den hohen Werten?
```{r}
checkout_hypothesis(basic_hypotheses.frame, "apap", prefix = "fucker")
```

```{r}
plotCombined(fuckerprd(seq(0,24,0.1), fuckerbest_parvec), fuckerdata)
```

```{r}
checkout_hypothesis(old_basic.frame, "apap", "old")
```


```{r}
cbind(olddata %>% as.data.frame() %>% arrange(study,group, time) %>% select(time,value,sigma,study,group, dosing_strategy),
fuckerdata %>% as.data.frame() %>% arrange(study,group, time)%>% select(name,time,value,sigma,study,group) %>% {names(.) <- paste0("fucker",names(.));.}) %>% 
  mutate(same_sig = near(sigma,fuckersigma, 0.01)) %>% 
  filter(!same_sig)

fuckerdata %>% as.data.frame() %>% arrange(study,group, time) %>% filter(name== "Mve_apap") %>% arrange(sigma)
```


```{r}
some_na %>% arrange(study)%>% select(name,time,value,sigma,study,group)
```


```{r}
data <-
  read_tsv("../data/limax_pkpd_v41_data.csv") %>%
  select(-model) %>% 
  rename(name = observer) %>% 
  rename(n = subjects) %>% 
  unique() #noch matthias sagen, dass lalazar2008 doppelte einträge hat


fitErrorModel_factors <- c("study", "group", "name", "BW", "PODOSE_apap", "IVDOSE_apap", 
"PODOSE_co2c13", "IVDOSE_co2c13", "Ri_co2c13", "ti_co2c13", "PODOSE_metc13", 
"IVDOSE_metc13", "ti_metc13")
some_na_before <- 
  data %>% 
  group_by(study, group, name) %>% 
  mutate(nna = n(), sna = sum(is.na(sigma))) %>% 
  filter(sna>0 & sna != nna) %>% 
  select(-sna, -nna) %>% 
  as.data.frame()
some_na <- some_na_before %>% fitErrorModel(fitErrorModel_factors)

none_or_all_na <- data %>% 
  group_by(study, group, name) %>% 
  mutate(nna = n(), sna = sum(is.na(sigma))) %>% 
  filter(sna==0 | sna == nna) %>% 
  select(-sna, -nna) %>% 
  as.data.frame()

data <- rbind(some_na, none_or_all_na) %>% 
  select(-n)
```

```{r}
mycond <- fuckerobj %>% getConditions() %>% set_names(.,.)
fuckercondwise <- map(mycond, function(cn) fuckerobj(fuckerbest_parvec, conditions = cn))
fuckercondwise2 <- map(mycond, function(cn) fuckerobj(prior_apap, conditions = cn))

oldcond <- oldobj%>% getConditions() %>% set_names(.,.)
oldcondwise <-  map(oldcond, function(cn) oldobj(fuckerbest_parvec, conditions = cn))
oldcondwise2 <- map(oldcond, function(cn) oldobj(prior_apap, conditions = cn))

cbind(tibble(mycond %>% str_trunc(15), fuckercondwise %>% map_dbl("value"), fuckercondwise2 %>% map_dbl("value")) %>% arrange(mycond),
tibble(oldcond%>% str_trunc(20), oldcondwise %>% map_dbl("value"), oldcondwise2 %>% map_dbl("value")) %>% arrange(oldcond)) %>% set_names(c("new_cond", "new obj, new fit", "new obj, old fit", "old cond", "old obj, new fit", "old obj, old fit")) %>% 
{.}
  # write_csv("comparsion_of_apap.csv")
```


