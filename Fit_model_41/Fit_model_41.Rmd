---
title: "Fitting model 39"
output: 
  html_document:
    toc: TRUE
---


Load all important libraries
```{r setup, message=FALSE, warning=FALSE, eval=TRUE, echo=FALSE}
knitr::opts_chunk$set(eval = TRUE)
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(fig.height = 10)
knitr::opts_chunk$set(fig.width = 15)
library(dMod)
library(stringr) # Um bequem mit strings zu arbeiten
library(tidyverse) # Viele Funktionen, u.a. für data.frames und ggplot2 für schöne plots
library(magrittr) # der Pipe-operator %>%: z.B: x =" a; y="f(x); z="g(y); wird zu z=" a %>% f %>% g
library(conveniencefunctions)



# load("2018_03_09_17_17_workspace.rda")
# for(i in lsdMod(classlist = "prdfn")) {loadDLL(i)}
```


# Read model
```{r}
source("../model/limax_pkpd_v41.R")
```


```{r}
pars_raw <- c(x0, p) 
pars_in_dxdtdmod <- c(getSymbols(dxdt_dmod), names(dxdt_dmod))
```

# Odemodels and predicition function

## Apap
```{r odemodel_apap}
free_pars_apap <- c("Ka_apap", "APAPD_HLM_CL", "APAPD_Km_apap")
odemodel_apap <- odemodel(dxdt_dmod, modelname = "odemodel_apap", fixed = setdiff(pars_in_dxdtdmod, c(free_pars_apap, "Aar_apap"))) # Aar_apap is not there to be optimized, but a variable which is a state is needed because of a bug in odemodel.

x_apap <- Xs(odemodel_apap)
```


## Bicarbonate

```{r odemodel_bic}
free_pars_bic <- c("Ka_co2c13", "KLU_EXCO2", "CO2FIX_HLM_CL", "KBO_FIXCO2", "KBO_RELCO2", "KBO_MAXCO2")
odemodel_bic <- odemodel(dxdt_dmod, modelname = "odemodel_bic", fixed = setdiff(pars_in_dxdtdmod, c(free_pars_bic, "Aar_apap"))) # Aar_apap is not there to be optimized, but a variable which is a state is needed because of a bug in odemodel.

x_bic <- Xs(odemodel_bic)
```

## Metc13

```{r odemodel_met}
free_pars_met <- c("Ka_metc13", "CYP1A2MET_CL", "CYP1A2MET_Km_met")
odemodel_met <- odemodel(dxdt_dmod, modelname = "odemodel_met", fixed = setdiff(pars_in_dxdtdmod, c(free_pars_met, "Aar_apap"))) # Aar_apap is not there to be optimized, but a variable which is a state is needed because of a bug in odemodel.

x_met <- Xs(odemodel_met)
```


# Observation functions

## Apap

```{r g_apap}
observables_apap <- y_dmod[c("Mve_apap")] %>% set_names(c("Mve_apap"))
g_apap <- Y(g = observables_apap, f = x_apap, attach.input = F, modelname = "g_apap", compile = F)
```

## Bicarbonate

```{r g_bic}
recovery_bic <- paste(y_dmod["Exhalation_co2c13"], "/ 60 * Mr_co2c13 / Ri_co2c13 * 100")
observables_bic <- c(recovery_bic, y_dmod[c("DOB", "P_CO2Fc13")])
names(observables_bic) <- c("cum_rec_co2c13", "DOB", "P_CO2F")

observables_bic["P_CO2F"] <- paste0(observables_bic["P_CO2F"], " + offset_bic")

g_bic <- Y(observables_bic, x_bic, attach.input = F, modelname = "g_bic", compile = F)
```

## Metc13

```{r g_met}
recovery_met <- paste(y_dmod["Exhalation_co2c13"], "/ init_PODOSE_metc13 * Mr_metc13 * 100" )
cum_met <- paste( "Abreath_co2c13/ init_PODOSE_metc13 * Mr_metc13 * 100")
observables_met <- c(recovery_met, cum_met) %>% set_names(c("mom_rec_metc13", "cum_rec_metc13"))

g_met <- Y(observables_met, x_met, attach.input = F, modelname = "g_met", compile = F)
```



# Data - read and preprocess
Read data, insert the default values for the parameters supplied in the data sheet. 

* Taheri rausschmeißen zum Fitten: Wird weiter unten getan

```{r, message=FALSE}
data <-
  read_tsv("../data/limax_pkpd_v41_data.csv") %>%
  select(-model) %>% 
  rename(name = observer) %>% 
  rename(n = subjects) %>% 
  unique() #noch matthias sagen, dass lalazar2008 doppelte einträge hat


fitErrorModel_factors <- c("study", "group", "name", "BW", "PODOSE_apap", "IVDOSE_apap", 
"PODOSE_co2c13", "IVDOSE_co2c13", "Ri_co2c13", "ti_co2c13", "PODOSE_metc13", 
"IVDOSE_metc13", "ti_metc13")
some_na <-
  data %>% 
  group_by(study, group, name) %>% 
  mutate(nna = n(), sna = sum(is.na(sigma))) %>% 
  filter(sna>0 & sna != nna) %>% 
  select(-sna, -nna) %>% 
  as.data.frame() %>% 
  fitErrorModel(factors = fitErrorModel_factors, plotting = F, blather = F) 

none_or_all_na <- data %>% 
  group_by(study, group, name) %>% 
  mutate(nna = n(), sna = sum(is.na(sigma))) %>% 
  filter(sna==0 | sna == nna) %>% 
  select(-sna, -nna) %>% 
  as.data.frame()

data <- rbind(some_na, none_or_all_na) %>% 
  select(-n)

supplied_pars <- names(pars_raw)[(names(pars_raw) %in% names(data))]
```


# Parameter trafos
## Apap
```{r p_apap}
data_apap <- data %>%  
  filter(simulation == "apap") %>% 
  select(-simulation) %>% 
  as.data.frame()
  
outer_pars_apap <- sort(c(supplied_pars, free_pars_apap))

trafo_apap <-
  pars_raw %>% 
  sort_by_name() %>% 
  replace((names(.) %in% outer_pars_apap), outer_pars_apap) %>% 
  
  branch(data_apap %>% as.datalist() %>% covariates()) %>% 
  
  minsert(supplied_pars) %>% 
  
  insert("x~exp(X)", x = free_pars_apap, X = toupper(free_pars_apap)) # backtrafo to linear pars from log-pars

p_apap <- P(trafo_apap, modelname = "p_apap", compile = F)

pars_apap <- log(pars_raw[free_pars_apap]) %>% set_names(toupper(free_pars_apap))

compile(g_apap, p_apap, output = "apap")

```

### Test plot
```{r plot_apap, eval=TRUE}
# loadDLL(x_apap)
times <- seq(0,24, 0.1)
plotCombined((g_apap*x_apap*p_apap)(times, pars_apap, deriv = F), data = data_apap %>% as.datalist(), name %in% names(observables_apap))

obj <- normL2(data_apap %>% as.datalist, (g_apap*x_apap*p_apap))
obj(getParameters(obj) %>% are_names_of(0))
```

## Bicarbonate

Some studies don't have sigmas. Estimate the errors for them while fitting. For this, we need to define an error model.
1. Split the data into studies a) with errors "_bic" and b) without errors "_bic_sigma_NA"
2. Define the error model (technically, this will also be an observation function: It "observes" the outputs of the model, e.g. "recovery", and calculates another variable from it, the error)
3. For both sets of data, "_bic", and "bic_sigma_NA", we now need condition specific parameters. Additionally, in "_bic_sigma_NA", we need to supply the parameters of our error model.

### Error model

```{r e_bic}
data_bic <- data %>% 
  filter(simulation == "bicarbonate")%>% 
  select(-simulation) %>% 
  as.data.frame()

studies_with_sigma_na <- data_bic %>% filter(is.na(sigma)) %>% .[["study"]] %>% unique
data_bic_sigma_NA <- data_bic %>% filter(study %in% studies_with_sigma_na)
data_bic <- data_bic %>% filter(! study %in% studies_with_sigma_na)

data_bic_sigma_NA$name %>% unique()

errors_bic_sigma_NA <- paste0("sqrt(s0_", names(observables_bic), "^2 + srel_", names(observables_bic), "^2 * ", names(observables_bic), "^2 )") %>% set_names(names(observables_bic))
errors_bic_sigma_NA["cum_rec_co2c13"] <- 1 #hierfür gibts eh keine daten und ich weiß nicht, ob ich es einfach weglassen kann

e_bic_sigma_NA <- Y(g = errors_bic_sigma_NA, f= (g_bic))
```

### Parameter trafo
```{r p_bic}
outer_pars_bic <- sort(c(supplied_pars, free_pars_bic))

trafo_bic<-
  c(pars_raw) %>% 
  sort_by_name() %>% 
  replace((names(.) %in% outer_pars_bic), outer_pars_bic) %>% 
  
  branch(data_bic %>% as.datalist() %>% covariates()) %>% # The table of covariates includes dosepar and dose, which are used in the next line
  
  minsert(supplied_pars) %>% 

  insert("x~exp(X)", x = getSymbols(mytrafo[[i]]), X = toupper(getSymbols(mytrafo[[i]]))) %>% 
  
  define("x~x", x = "offset_bic")

p_bic <- P(trafo_bic, modelname = "p_bic", compile = F)

pars_bic <- getParameters(p_bic) %>% are_names_of(0)
```

```{r p_bic_sigma_NA}
pars_errors_bic_sigma_NA <- getSymbols(errors_bic_sigma_NA) %>% str_subset("^s") %>% are_names_of(1)

outer_pars_bic <- sort(c(supplied_pars, free_pars_bic, names(pars_errors_bic_sigma_NA)))

trafo_bic_sigma_NA <-
  c(pars_raw, pars_errors_bic_sigma_NA) %>% 
  sort_by_name() %>% 
  replace((names(.) %in% outer_pars_bic), outer_pars_bic) %>% 
  
  branch(data_bic_sigma_NA %>% as.datalist() %>% covariates()) %>% # The table of covariates includes dosepar and dose, which are used in the next line
  
  minsert(supplied_pars) %>% 
  
  insert("x~exp(X)", x = getSymbols(mytrafo[[i]]), X = toupper(getSymbols(mytrafo[[i]]))) %>% 
  
  define("x~x", x = "offset_bic")

p_bic_sigma_NA <- P(trafo_bic_sigma_NA, modelname = "p_bic_sig", compile = F)

pars_bic_sigma_NA <- getParameters(p_bic_sigma_NA) %>% are_names_of(0)

# p_bic_sigma_NA(pars_bic_sigma_NA)

compile(g_bic, p_bic, p_bic_sigma_NA, output = "bic")
```


### Example plot
```{r}
loadDLL(x_bic)
(g_bic*x_bic*p_bic_sigma_NA)(times*10, pars_bic_sigma_NA, deriv = F) %>%  plotPrediction(name %in% names(observables_bic))
(g_bic*x_bic*p_bic)(times*10, pars_bic, deriv = F) %>%  
  # lapply(. %>% as.tibble)
  plotPrediction(name %in% names(observables_bic))
# obj <- normL2(data_bic %>% as.datalist,(g_bic*x_bic*p_bic))

```


## Metc13

The same game for the data sets without sigmas applies here. Read the description for Bic.

### Error model
```{r e_met}
data_met <- data %>% 
  filter(simulation == "methacetin")%>% 
  select(-simulation) %>% 
  as.data.frame()

studies_with_sigma_na <- data_met %>% filter(is.na(sigma)) %>% .[["study"]] %>% unique
data_met_sigma_NA <- data_met %>% filter(study %in% studies_with_sigma_na)
data_met <- data_met %>% filter(! study %in% studies_with_sigma_na)

errors_met_sigma_NA <- paste0("sqrt(s0_", names(observables_met), "^2 + srel_", names(observables_met), "^2 * ", names(observables_met), "^2)") %>% set_names(names(observables_met))
errors_met_sigma_NA["mom_rec_metc13"] <- 1 #hierfür gibts eh keine daten mit sigma=NA

e_met_sigma_NA <- Y(g = errors_met_sigma_NA, f= (g_met))


```

### Parameter trafo
```{r p_met}
outer_pars_met <- sort(c(supplied_pars, free_pars_met))

trafo_met<-
  c(pars_raw) %>% 
  sort_by_name() %>% 
  replace((names(.) %in% outer_pars_met), outer_pars_met) %>% 
  
  branch(data_met %>% as.datalist() %>% covariates()) %>%  # The table of covariates includes dosepar and dose, which are used in the next line
  
  minsert(supplied_pars) %>% 

  define("init_PODOSE_metc13~podose", podose = mytrafo[[i]]["PODOSE_metc13"]) %>% # For the observables, I need the initial dose as a fixed parameter which doesn't change. Because the PODOSE_metc13 is also a state, I need to duplicate this parameters
    
  insert("x~exp(X)", x = getSymbols(mytrafo[[i]]), X = toupper(getSymbols(mytrafo[[i]]))) 

p_met <- P(trafo_met, modelname = "p_met", compile = F)

pars_met <- getParameters(p_met) %>% are_names_of(0)
```


```{r p_met_sigma_NA}
pars_errors_met_sigma_NA <- getSymbols(errors_met_sigma_NA) %>% str_subset("^s") %>%  are_names_of(1)

outer_pars_met <- sort(c(supplied_pars, free_pars_met, names(pars_errors_met_sigma_NA)))

trafo_met_sigma_NA <-
  c(pars_raw, pars_errors_met_sigma_NA) %>% 
  sort_by_name() %>% 
  replace((names(.) %in% outer_pars_met), outer_pars_met) %>% 
  
  branch(data_met_sigma_NA %>% as.datalist() %>% covariates()) %>% # The table of covariates includes dosepar and dose, which are used in the next line
  
  minsert(supplied_pars) %>% 
  
  define("init_PODOSE_metc13~podose", podose = mytrafo[[i]]["PODOSE_metc13"]) %>% # For the observables, I need the initial dose as a fixed parameter which doesn't change. Because the PODOSE_metc13 is also a state, I need to duplicate this parameters
  
  insert("x~exp(X)", x = getSymbols(mytrafo[[i]]), X = toupper(getSymbols(mytrafo[[i]])))



p_met_sigma_NA <- P(trafo_met_sigma_NA, modelname = "p_met_sig", compile = F)

pars_met_sigma_NA <- getParameters(p_met_sigma_NA) %>% are_names_of(0)

compile(g_met, p_met, p_met_sigma_NA, output = "met")
```

### Example plot
```{r}
loadDLL(x_met)
(g_met*x_met*p_met_sigma_NA)(times*100, pars_met_sigma_NA, deriv = F) %>% plotPrediction(name %in% names(observables_met))
```



# Bic and met together
```{r x, g and e bicmet}
free_pars_bicmet <- c(free_pars_bic, free_pars_met)
odemodel_bicmet <- odemodel(dxdt_dmod, modelname = "odemodel_bicmet", fixed = setdiff(pars_in_dxdtdmod, c(free_pars_bicmet, "Aar_apap"))) # Aar_apap is not there to be optimized, but a variable which is a state is needed because of a bug in odemodel.
x_bicmet <- Xs(odemodel_bicmet)

g_bicmet <- Y(c(observables_bic, observables_met), x_bicmet, attach.input = F, modelname = "g_bicmet", compile = F)

e_bicmet <- Y(c(errors_bic_sigma_NA, errors_met_sigma_NA), g_bicmet)# , modelname = "e_bicmet", compile = F)
```

```{r data and p bicmet}
data_bicmet <- rbind(data_bic, data_met)
data_bicmet_sigma_NA <- rbind(data_bic_sigma_NA, data_met_sigma_NA)

outer_pars_bic <- sort(c(supplied_pars, free_pars_bic))
outer_pars_bic_sigma_NA <- sort(c(supplied_pars, free_pars_bic, names(pars_errors_bic_sigma_NA)))

outer_pars_met <- sort(c(supplied_pars, free_pars_met))
outer_pars_met_sigma_NA <- sort(c(supplied_pars, free_pars_met, names(pars_errors_met_sigma_NA)))

trafo_bicmet<-
  c(pars_raw) %>% 
  sort_by_name() %>% 
  replace((names(.) %in% unique(c(outer_pars_bic, outer_pars_met))), sort(unique(c(outer_pars_bic, outer_pars_met)))) %>% 
  
  branch(data_bicmet %>% as.datalist() %>% covariates()) %>% # The table of covariates includes dosepar and dose, which are used in the next line
  
  minsert(supplied_pars) %>% 

  define("init_PODOSE_metc13~podose", podose = mytrafo[[i]]["PODOSE_metc13"]) %>% # For the observables, I need the initial dose as a fixed parameter which doesn't change. Because the PODOSE_metc13 is also a state, I need to duplicate this parameters

  insert("x~exp(X)", x = getSymbols(mytrafo[[i]]), X = toupper(getSymbols(mytrafo[[i]]))) %>% 
  
  define("x~x", x = "offset_bic")


trafo_bicmet_sigma_NA <-
  c(pars_raw, pars_errors_bic_sigma_NA, pars_errors_met_sigma_NA) %>% 
  sort_by_name() %>% 
  replace((names(.) %in% unique(c(outer_pars_bic_sigma_NA, outer_pars_met_sigma_NA))), sort(unique(c(outer_pars_bic_sigma_NA, outer_pars_met_sigma_NA)))) %>% 
  
  branch(data_bicmet_sigma_NA %>% as.datalist() %>% covariates()) %>% # The table of covariates includes dosepar and dose, which are used in the next line
  minsert(supplied_pars) %>% 
  #bic

  #met
  define("init_PODOSE_metc13~podose", podose = mytrafo[[i]]["PODOSE_metc13"]) %>% # For the observables, I need the initial dose as a fixed parameter which doesn't change. Because the PODOSE_metc13 is also a state, I need to duplicate this parameters

  insert("x~exp(X)", x = getSymbols(mytrafo[[i]]), X = toupper(getSymbols(mytrafo[[i]]))) %>% 
  

  define("x~x", x = "offset_bic") %>% 
  
  #met
  {.}


p_bicmet <- P(trafo_bicmet, modelname = "p_bicmet", compile = F)
pars_bicmet <- getParameters(p_bicmet) %>% are_names_of(0)

p_bicmet_sigma_NA <- P(trafo_bicmet_sigma_NA, modelname = "p_sig_bicmet", compile = F)
pars_bicmet_sigma_NA <- getParameters(p_bicmet_sigma_NA) %>% are_names_of(0)

compile(g_bicmet, p_bicmet, p_bicmet_sigma_NA, cores = 3, output = "bicmet")
```

# Apap, bic and met

```{r x, g and e apapbicmet}
free_pars_apapbicmet <- c(free_pars_apap, free_pars_bic, free_pars_met)
odemodel_apapbicmet <- odemodel(dxdt_dmod, modelname = "odemodel_apapbicmet", fixed = setdiff(pars_in_dxdtdmod, c(free_pars_apapbicmet, "Aar_apap"))) # Aar_apap is not there to be optimized, but a variable which is a state is needed because of a bug in odemodel.
x_apapbicmet <- Xs(odemodel_apapbicmet)

g_apapbicmet <- Y(c(observables_apap, observables_bic, observables_met), x_apapbicmet, attach.input = F, modelname = "g_apapbicmet", compile = F)

e_apapbicmet <- Y(c(errors_bic_sigma_NA, errors_met_sigma_NA), g_apapbicmet)#, modelname = "e_apapbicmet", compile = F) #cant cope with NaNs passed to it, if compiled
```

```{r data and p apapbicmet}
data_apapbicmet <- rbind(data_apap, data_bic, data_met)
data_apapbicmet_sigma_NA <- rbind(data_bic_sigma_NA, data_met_sigma_NA)

outer_pars_apap <- sort(c(supplied_pars,free_pars_apap))

outer_pars_bic <- sort(c(supplied_pars, free_pars_bic))
outer_pars_bic_sigma_NA <- sort(c(supplied_pars, free_pars_bic, names(pars_errors_bic_sigma_NA)))

outer_pars_met <- sort(c(supplied_pars, free_pars_met))
outer_pars_met_sigma_NA <- sort(c(supplied_pars, free_pars_met, names(pars_errors_met_sigma_NA)))

outer_pars_apapbicmet <- sort(unique(c(outer_pars_apap, outer_pars_bic, outer_pars_met)))
outer_pars_apapbicmet_sigma_NA <- sort(unique(c(outer_pars_apap, outer_pars_bic, outer_pars_bic_sigma_NA, outer_pars_met,outer_pars_met_sigma_NA)))

trafo_apapbicmet<-
  c(pars_raw) %>% 
  sort_by_name() %>% 
  replace(names(.) %in% outer_pars_apapbicmet, outer_pars_apapbicmet) %>% 
  
  branch(data_apapbicmet %>% as.datalist() %>% covariates()) %>% # The table of covariates includes dosepar and dose, which are used in the next line
  
  minsert(supplied_pars) %>% 
  
  define("init_PODOSE_metc13~podose", podose = mytrafo[[i]]["PODOSE_metc13"]) %>% # For the observables, I need the initial dose as a fixed parameter which doesn't change. Because the PODOSE_metc13 is also a state, I need to duplicate this parameters
  
  insert("x~exp(X)", x = getSymbols(mytrafo[[i]]), X = toupper(getSymbols(mytrafo[[i]]))) %>% 
  
  define("x~x", x = "offset_bic")


trafo_apapbicmet_sigma_NA <-
  c(pars_raw, pars_errors_bic_sigma_NA, pars_errors_met_sigma_NA) %>% 
  sort_by_name() %>% 
  replace(names(.) %in% outer_pars_apapbicmet_sigma_NA, outer_pars_apapbicmet_sigma_NA) %>% 
  
  branch(data_apapbicmet_sigma_NA %>% as.datalist() %>% covariates()) %>% # The table of covariates includes dosepar and dose, which are used in the next line
  minsert(supplied_pars) %>% 
  #bic

  #met
  define("init_PODOSE_metc13~podose", podose = mytrafo[[i]]["PODOSE_metc13"]) %>% # For the observables, I need the initial dose as a fixed parameter which doesn't change. Because the PODOSE_metc13 is also a state, I need to duplicate this parameters
  
  insert("x~exp(X)", x = getSymbols(mytrafo[[i]]), X = toupper(getSymbols(mytrafo[[i]]))) %>% 
  
  #bic
  define("x~x", x = "offset_bic") %>% 
  
  #met
  {.}



p_apapbicmet <- P(trafo_apapbicmet, modelname = "p_apapbicmet", compile = F)
pars_apapbicmet <- getParameters(p_apapbicmet) %>% are_names_of(0)

p_apapbicmet_sigma_NA <- P(trafo_apapbicmet_sigma_NA, modelname = "p_sig_apapbicmet", compile = F)

pars_apapbicmet_sigma_NA <- getParameters(p_apapbicmet_sigma_NA) %>% are_names_of(0)


compile(g_apapbicmet,  p_apapbicmet, p_apapbicmet_sigma_NA, cores = 3, output = "apapbicmet")
```


# dMod.frames

```{r initialize dMod.frames }
# remove(basic_hypotheses.frame, bicmet.frame, apapbicmet.frame)

basic_hypotheses.frame <- tibble(hypothesis = c("apap",  "bic", "met"),
                     x = list(x_apap,  x_bic, x_met)) %>% 
  add_column( g = list(g_apap,  g_bic, g_met)) %>% 
  add_column(p_0 = list(p_apap,  p_bic, p_met),
             data_0 = list(data_apap,  data_bic, data_met),
             p_sig = list(NULL,  p_bic_sigma_NA, p_met_sigma_NA),
             e = list(NULL,  e_bic_sigma_NA, e_met_sigma_NA),
             data_sig = list(NULL,  data_bic_sigma_NA, data_met_sigma_NA)
  )
# basic_hypotheses.frame <- basic_hypotheses.frame[1,] # keep only apap

bicmet.frame <- tibble(
  hypothesis = "bicmet",
  x = list(x_bicmet),
  g = list(g_bicmet),
  p_0 = list(p_bicmet),
  data_0 = list(data_bicmet),
  p_sig = list(p_bicmet_sigma_NA),
  e = list(e_bicmet),
  data_sig = list(data_bicmet_sigma_NA)
)

apapbicmet.frame <- tibble(
  hypothesis = "apapbicmet",
  x = list(x_apapbicmet),
  g = list(g_apapbicmet),
  p_0 = list(p_apapbicmet),
  data_0 = list(data_apapbicmet),
  p_sig = list(p_apapbicmet_sigma_NA),
  e = list(e_apapbicmet),
  data_sig = list(data_apapbicmet_sigma_NA)
)

```


# Prepare fits

```{r functions for dMod.frames to create objfuns and make them frame smaller again}
dMf_append_objfuns <- function(dMod.frame) dMod.frame %>% 
    mutate(data_0 = map(data_0, as.datalist),
         data_sig = map(data_sig, as.datalist)) %>% 
  mutate(prd_0 = map(seq_along(x), function(i) cfn(g[[i]], cfn(x[[i]],p_0[[i]]))),
         prd_sig = map(seq_along(x), function(i) cfn(g[[i]], cfn(x[[i]],p_sig[[i]])))) %>% 
  mutate(obj_0 = map(seq_along(x), function(i) normL2(data_0[[i]], prd_0[[i]])),
         obj_sig = map(seq_along(x), function(i) cf_normL2(data = data_sig[[i]], prd_sig[[i]], e = e[[i]]))) %>% 
  
  mutate(obj = map(seq_along(x), function(i) obj_sig[[i]]+obj_0[[i]])) %>% 
  mutate(prd = map(seq_along(x), function(i) prd_sig[[i]]+prd_0[[i]])) %>% 
  mutate(data= map(seq_along(x), function(i) data_sig[[i]]+data_0[[i]])) 

dMf_reduce <- function(dMod.frame) dMod.frame %>% 
  select(-contains("_0")) %>% 
  select(-contains("_sig"))
```

```{r augment dMod.frames}
basic_hypotheses.frame <- basic_hypotheses.frame %>% 
  dMf_append_objfuns()
  
bicmet.frame <- bicmet.frame%>% 
  dMf_append_objfuns()

apapbicmet.frame <- apapbicmet.frame%>% 
  dMf_append_objfuns()
```


```{r test objfuns}
basic_hypotheses.frame %>% .$obj %>% walk(loadDLL)
bicmet.frame %>% .$obj %>% walk(loadDLL)
apapbicmet.frame %>% .$obj %>% walk(loadDLL)


# basic_hypotheses.frame %>% mutate(test = map(seq_along(x), function(i) {
#   return(obj[[i]](getParameters(obj[[i]]) %>% are_names_of(0)))})
#   ) %>% .$test

bicmet.frame %>% mutate(test = map(seq_along(x), function(i) obj_sig[[i]](getParameters(obj_sig[[i]]) %>% are_names_of(0)))) %>% .$test

apapbicmet.frame%>% dMf_reduce() %>%  mutate(test = map(seq_along(x), function(i) obj[[i]](getParameters(obj[[i]]) %>% are_names_of(0)))) %>% .$test



```


```{r}
save.image(tpaste0("workspace_with_dMod.frames.rda"))
```

# Start fits
```{r load workspace up to here}
load("2018_03_31_02_21_workspace_with_dMod.frames.rda")
rbind(bicmet.frame, apapbicmet.frame) %>% .$obj %>% walk(loadDLL)
```

```{r start fits with broad sampling}
apapbicmet.frame <- apapbicmet.frame %>% dMf_reduce()

apapbicmet.frame[["pars"]] <- getParameters(apapbicmet.frame[["obj"]][[1]]) %>% are_names_of(0) %>% list

fit_apapbicmet_broad_sampling <- runbg({
  ncores <- detectFreeCores()
  assign("ncores", ncores, pos = .GlobalEnv)

  apapbicmet.frame %>%
    mutate(fits = map(seq_along(x), function(i) {
      assign("fit_obj", obj[[i]], pos = .GlobalEnv)
      assign("fit_pars", pars[[i]], pos = .GlobalEnv)
      assign("fit_studyname", paste0("fits", hypothesis[[i]]), pos = .GlobalEnv)
      mstrust(objfun = fit_obj, center = fit_pars, studyname = fit_studyname,
              sd = 4,
              blather = F, cores = ncores, fits = 15*ncores)
    }))
  }, machine = paste0("knecht", 1:5), filename = paste0("tmp_",tpaste0("fit_apapbicmet_broad_sampling")), input = "apapbicmet.frame")


bicmet.frame <- bicmet.frame %>% dMf_reduce()

bicmet.frame[["pars"]] <- getParameters(bicmet.frame[["obj"]][[1]]) %>% are_names_of(0) %>% list

fit_bicmet_broad_sampling <- runbg({
  ncores <- detectFreeCores()
  assign("ncores", ncores, pos = .GlobalEnv)
  
  bicmet.frame %>%
    mutate(fits = map(seq_along(x), function(i) {
      assign("fit_obj", obj[[i]], pos = .GlobalEnv)
      assign("fit_pars", pars[[i]], pos = .GlobalEnv)
      assign("fit_studyname", paste0("fits", hypothesis[[i]]), pos = .GlobalEnv)
      mstrust(objfun = fit_obj, center = fit_pars, studyname = fit_studyname,
              sd = 4,
              blather = F, cores = ncores, fits = 25*ncores)
    }))
}, machine = paste0("ruprecht", 1:2), filename = paste0("tmp_",tpaste0("fit_bicmet_broad_sampling")), input = "bicmet.frame")

```

```{r}
save.image(tpaste0("workspace_apapbicmet_and_bicmet_fits_started.rda"))
```

# Load and look at fits
```{r get fit results from knechte}
# load("2018_03_31_02_30_workspace_apapbicmet_and_bicmet_fits_started.rda")
# apapbicmet.frame %>% .$obj %>% walk(loadDLL)
# apapbicmet.frame[["fits"]] <- fit_apapbicmet_broad_sampling$get() %>% map("fits") %>% map(1) %>%  Reduce(c.parlist,.) %>% list()
# save.image(tpaste0("workspace_apapbicmet_with_fits.rda"))
```

```{r }
load("2018_03_31_03_29_workspace_apapbicmet_with_fits.rda")
apapbicmet.frame %>% .$obj %>% walk(loadDLL)
saveRDS(apapbicmet.frame$parframes, tpaste0("fits_apapbicmet_1.rds"))
```

```{r}
# apapbicmet.frame <- apapbicmet.frame %>% mutate(prd = map(prd, function(i) {controls(i, name = "attach.input") <- FALSE; i} ))

apapbicmet.frame <- 
  apapbicmet.frame %>% 
  dMf_expand_fits() %>% 
  dMf_append_plots()
```

no nice steps
```{r}
apapbicmet.frame$parframes %>% .[[1]] %>% .[1:800,] %>% plotValues()
```

The error-model just kills the steps, I think. Maybe I should reduce it.
Except for in Krumbiegel, it appears as if the absolute error can be kicked out
```{r}
apapbicmet.frame$parframes %>% .[[1]] %>% .[1:20,] %>% plotPars() +
  coord_cartesian(ylim = c(-5,5))
```

```{r}
apapbicmet.frame$best_parvec
```

Browsing through the conditions, one can see that met isnt met very well (haha)
```{r}
apapbicmet.frame %>% dMf_append_plots() %>% .[["plot_combined"]]

plotCombined(apapbicmet.frame[["prd"]][[1]](seq(0,24,0.1), 
                                            apapbicmet.frame$best_parvec[[1]], deriv = F),
             apapbicmet.frame[["data"]][[1]], 
             condition %in% rownames(rbind(data_met, data_met_sigma_NA) %>% as.datalist %>% covariates()) &
               name %in% names(observables_met)#getEquations(apapbicmet.frame[["g"]][[1]])[[1]])
             )
# ggplotly()
```

look at differences in parameters wrt the best parvec
```{r}
myparframe <- apapbicmet.frame$parframes[[1]]

myparframe[,5:27] <- myparframe[,5:27] %>% map(function(i) return(i - i[1]))

myparframe %>% .[1:10,] %>% plotPars() + 
  coord_cartesian(ylim = c(-2,2))
```


# Restart some fits

```{r}
basic_hypotheses.frame <- basic_hypotheses.frame %>% dMf_reduce()

basic_hypotheses.frame <- basic_hypotheses.frame %>% mutate(pars = map(seq_along(x), function(i)  getParameters(obj[[i]]) %>% are_names_of(0)))

fit_basic_hypotheses_broad_sampling <- runbg({
  ncores <- detectFreeCores()
  assign("ncores", ncores, pos = .GlobalEnv)

  basic_hypotheses.frame %>%
    mutate(fits = map(seq_along(x), function(i) {
      assign("fit_obj", obj[[i]], pos = .GlobalEnv)
      assign("fit_pars", pars[[i]], pos = .GlobalEnv)
      assign("fit_studyname", paste0("fits", hypothesis[[i]]), pos = .GlobalEnv)
      mstrust(objfun = fit_obj, center = fit_pars, studyname = fit_studyname,
              sd = 4,
              blather = F, cores = ncores, fits = 15*ncores)
    }))
  }, machine = paste0("knecht", 1:5), filename = paste0("tmp_",tpaste0("fit_basic_hypotheses")), input = "basic_hypotheses.frame")
```

```{r}
save.image(tpaste0("workspace_basic_hypotheses_fits_started.rda"))
```

# To do next: 

* Get the fits, compare with old results
* Start new fits with priors around the old results
* Save fits as rds in the future!

# Get old fits

```{r old fits}
old_basic.frame <- readRDS("2018_03_25_21_06_fit.frame.rds")
prior_apap <- old_basic.frame %>% dMf_expand_fits() %>% .$best_parvec %>% .[[1]]
```

```{r}
old_bicmet.frame <- readRDS("../fitting/2018_03_29_18_09_bicmet_refitted.rds")
prior_bicmet <- old_bicmet.frame%>% dMf_expand_fits() %>% .$best_parvec %>% .[[1]]
```

# Start fits with prior around old fits

```{r}
prior <- c(prior_apap, prior_bicmet) %>% .[!str_detect(names(.), "^S")]
class(prior) <- "numeric"
attr(prior, "deriv") <- NULL
dput(prior)
apapbicmet_prior.frame <- apapbicmet.frame

apapbicmet_prior.frame <- apapbicmet_prior.frame[,1:8]
apapbicmet_prior.frame[["hypothesis"]] <- "Prior around old fits"
apapbicmet_prior.frame <- map(1:4, function(i) apapbicmet_prior.frame) %>% do.call(rbind,.)
apapbicmet_prior.frame <-apapbicmet_prior.frame %>% mutate(sigma_prior = c(0.0001, 0.01, 1, 10)) %>% mutate(mu_prior = map(1:4, function(i) structure(c(0.255612598380746, 0.538956047621218, -1.44260842367156, 
-1.02673969006676, -0.686131603272496, -10.5578956723622, 4.68324578583817, 
1.65222659290464, 2.48470059603214, -3.6567384812666, -11.1322105945781, 
0.385743406722386, -0.0111086946469918), .Names = c("KA_APAP", 
"APAPD_HLM_CL", "APAPD_KM_APAP", "CO2FIX_HLM_CL", "CYP1A2MET_CL", 
"CYP1A2MET_KM_MET", "KA_CO2C13", "KA_METC13", "KBO_FIXCO2", "KBO_MAXCO2", 
"KBO_RELCO2", "KLU_EXCO2", "offset_bic")))) %>% 
  mutate(obj = map(seq_along(x), function(i) obj[[i]] + constraintL2(mu_prior[[i]], sigma = sigma_prior[[i]])))
```

```{r}
apapbicmet_prior.frame %>% mutate(test = map(seq_along(x), function(i) obj[[i]](pars[[i]]))) %>% .$test
```

```{r}
fit_apapbicmet_with_old_prior <- runbg({
  ncores <- detectFreeCores()
  assign("ncores", ncores, pos = .GlobalEnv)

  apapbicmet_prior.frame %>%
    mutate(fits = map(seq_along(x), function(i) {
      assign("fit_obj", obj[[i]], pos = .GlobalEnv)
      assign("fit_pars", pars[[i]], pos = .GlobalEnv)
      assign("fit_studyname", paste0("fits", hypothesis[[i]]), pos = .GlobalEnv)
      mstrust(objfun = fit_obj, center = fit_pars, studyname = fit_studyname,
              sd = 4,
              blather = F, cores = ncores, fits = 15*ncores)
    }))
  }, machine = paste0("knecht", 1:5), filename = paste0("tmp_",tpaste0("fit_apapbicmet_with_old_prior")), input = "apapbicmet_prior.frame")

saveRDS(fit_apapbicmet_with_old_prior, tpaste0("fit_apapbicmet_with_old_prior_started.rds"))
```


# Get new "basic" fits

```{r}
myfits <- fit_basic_hypotheses_broad_sampling$get() 

basic_hypotheses.frame[["fits"]] <- myfits %>% map("fits") %>% transpose() %>% map(function(i) Reduce(c.parlist, i))

saveRDS(basic_hypotheses.frame, tpaste0("fits_basic_hypotheses")) # "2018_03_31_04_35_fits_basic_hypotheses"
```

```{r}
basic_hypotheses.frame <- basic_hypotheses.frame %>% dMf_expand_fits() %>% dMf_append_plots()
```

Was ist da los, wieso findet er Ka_apap nicht mehr bei den hohen Werten?
```{r}
checkout_hypothesis(basic_hypotheses.frame, "apap", prefix = "fucker")
```




# Start fits without Mohr
```{r load workspace with dMod.frames, dependson="setup"}
load("2018_03_31_02_21_workspace_with_dMod.frames.rda")
rbind(bicmet.frame, apapbicmet.frame) %>% .$obj %>% walk(loadDLL)
```


```{r prepare no mohr frame}
no_mohr.frame <- apapbicmet.frame
no_mohr.frame <- no_mohr.frame %>% 
  mutate(data_0 = map(data_0, . %>% 
                        .[!((names(.) %>% str_detect("lbert")) & (names(.) %>% str_detect("caps")))] %>% 
                        .[!(names(.) %>% str_detect("Mohr"))])) %>% 
  mutate(hypothesis= "apapbicmet no albert caps, no Mohr") %>% 
  mutate(prd_0 = map(seq_along(x), function(i) cfn(g[[i]], cfn(x[[i]],p_0[[i]]))),
         prd_sig = map(seq_along(x), function(i) cfn(g[[i]], cfn(x[[i]],p_sig[[i]])))) %>% 
  mutate(obj_0 = map(seq_along(x), function(i) normL2(data_0[[i]], prd_0[[i]])),
         obj_sig = map(seq_along(x), function(i) cf_normL2(data = data_sig[[i]], prd_sig[[i]], e = e[[i]]))) %>% 
  
  mutate(obj = map(seq_along(x), function(i) obj_sig[[i]]+obj_0[[i]])) %>% 
  mutate(prd = map(seq_along(x), function(i) prd_sig[[i]]+prd_0[[i]])) %>% 
  mutate(data= map(seq_along(x), function(i) data_sig[[i]]+data_0[[i]])) 
  
```


```{r start no mohr fits}
no_mohr.frame <- no_mohr.frame %>% dMf_reduce()

no_mohr.frame[["pars"]] <- getParameters(no_mohr.frame[["obj"]][[1]]) %>% are_names_of(0) %>% list

fit_job_no_mohr_broad_sampling <- runbg({
  ncores <- detectFreeCores()
  assign("ncores", ncores, pos = .GlobalEnv)

  no_mohr.frame %>%
    mutate(fits = map(seq_along(x), function(i) {
      assign("fit_obj", obj[[i]], pos = .GlobalEnv)
      assign("fit_pars", pars[[i]], pos = .GlobalEnv)
      assign("fit_studyname", paste0("fits", hypothesis[[i]]), pos = .GlobalEnv)
      mstrust(objfun = fit_obj, center = fit_pars, studyname = fit_studyname,
              sd = 4,
              blather = F, cores = ncores, fits = 10*ncores)
    }))
}, machine = paste0("knecht", c(1,2,4)), filename = paste0("tmp_",tpaste0("fit_job_no_mohr_broad_sampling")), input = "no_mohr.frame")
saveRDS(fit_job_no_mohr_broad_sampling, tpaste0("fit_job_no_mohr_broad_sampling.rds"))
```

## get and analyze fits without mohr and albert_caps

```{r get no mohr fits}
# fit_job_no_mohr_broad_sampling <- readRDS("2018_04_01_19_58_fit_job_no_mohr_broad_sampling.rds")
# no_mohr.frame$fits <- fit_job_no_mohr_broad_sampling$get() %>% map("fits") %>% map(1) %>%  Reduce(c.parlist,.) %>% list()
# saveRDS(no_mohr.frame, tpaste0("fits_no_mohr_broad_sampling.rds"))
no_mohr.frame <- readRDS("2018_04_01_20_34_fits_no_mohr_broad_sampling.rds")
```


```{r expand no mohr fits}
no_mohr.frame <- no_mohr.frame %>% 
  dMf_expand_fits()
```

```{r no mohr plot values}
no_mohr.frame$parframes %>% .[[1]] %>% .[1:100] %>% plotValues()
```

```{r}
no_mohr.frame$parframes %>% .[[1]] %>% .[1:50] %>% plotPars()
```

```{r}
cond_apap <- apapbicmet.frame$obj[[1]]

plotCombined(no_mohr.frame$best_prediction[[1]], data  = no_mohr.frame$data[[1]], name  %in% names(observables_bic))

```

# Profile Likelihoods

# PL no Mohr, no albert
```{r, dependson="setup"}
load("2018_03_31_02_21_workspace_with_dMod.frames.rda")
no_mohr.frame <- readRDS("2018_04_01_20_34_fits_no_mohr_broad_sampling.rds") %>% dMf_expand_fits()

rbind(no_mohr.frame, bicmet.frame, apapbicmet.frame) %>% .$obj %>% walk(loadDLL)
```


```{r}
profile_job_no_mohr <- runbg({
  ncores <- detectFreeCores()
  assign("ncores", ncores, pos = .GlobalEnv)

  no_mohr.frame %>%
    mutate(profiles = map(seq_along(x), function(i) {
      assign("fit_obj", obj[[i]], pos = .GlobalEnv)
      assign("fit_pars", best_parvec[[i]], pos = .GlobalEnv)
      profile(obj = fit_obj, pars = fit_pars, whichPar = names(fit_pars), cores = ncores)
    }))
}, machine = paste0("knecht", c(1)), filename = paste0("tmp_",tpaste0("profile_job_no_mohr")), input = "no_mohr.frame")
saveRDS(profile_job_no_mohr, tpaste0("profile_job_no_mohr.rds"))
```




## PL no Mohr, no albert, fixed errorpars
```{r, dependson="setup"}
load("2018_03_31_02_21_workspace_with_dMod.frames.rda")
no_mohr.frame <- readRDS("2018_04_01_20_34_fits_no_mohr_broad_sampling.rds")

rbind(bicmet.frame, apapbicmet.frame) %>% .$obj %>% walk(loadDLL)
no_mohr.frame %>% .$obj %>% walk(loadDLL)
no_mohr.frame <- no_mohr.frame %>% dMf_expand_fits()
```


```{r}
profile_job_no_mohr_fix_error_pars <- runbg({
  ncores <- detectFreeCores()
  assign("ncores", ncores, pos = .GlobalEnv)
  
  no_mohr.frame %>%
    mutate(hypothesis = "No albert_caps and mohr, Profiles with fixed error pars") %>% 
    mutate(profiles = map(seq_along(x), function(i) {
      assign("fit_obj", obj[[i]], pos = .GlobalEnv)
      assign("fit_pars", best_parvec[[i]], pos = .GlobalEnv)
      
      fixedPars <- best_parvec[[i]] %>% .[str_detect(names(.),"^S")] 
      assign("fixed_pars", fixedPars, pos = .GlobalEnv)
      
      whichPars <- best_parvec[[i]][setdiff(names(best_parvec[[i]]), names(fixed_pars)) ]
      assign("which_pars", whichPars, pos = .GlobalEnv)

      profile(obj = fit_obj, pars = which_pars, whichPar = names(which_pars), cores = ncores, fixed = fixed_pars)
    }))
}, machine = paste0("knecht", c(2)), filename = paste0("tmp_",tpaste0("profile_job_no_mohr_fix_error_pars")), input = "no_mohr.frame")
saveRDS(profile_job_no_mohr_fix_error_pars, tpaste0("profile_job_no_mohr_fix_error_pars.rds"))
```




## PL no Mohr, no albert, fiix errorpars, bigger stepsize
```{r, dependson="setup"}
load("2018_03_31_02_21_workspace_with_dMod.frames.rda")
no_mohr.frame <- readRDS("2018_04_01_20_34_fits_no_mohr_broad_sampling.rds")

rbind(bicmet.frame, apapbicmet.frame) %>% .$obj %>% walk(loadDLL)
no_mohr.frame %>% .$obj %>% walk(loadDLL)
no_mohr.frame <- no_mohr.frame %>% dMf_expand_fits()
```


```{r}
profile_job_no_mohr_fix_error_pars_bigger_stepsize <- runbg({
  ncores <- detectFreeCores()
  assign("ncores", ncores, pos = .GlobalEnv)
  
  no_mohr.frame %>%
    mutate(hypothesis = "No albert_caps and mohr, Profiles with fixed error pars, bigger stepsize") %>% 
    mutate(profiles = map(seq_along(x), function(i) {
      assign("fit_obj", obj[[i]], pos = .GlobalEnv)
      assign("fit_pars", best_parvec[[i]], pos = .GlobalEnv)
      
      fixedPars <- best_parvec[[i]] %>% .[str_detect(names(.),"^S")] 
      assign("fixed_pars", fixedPars, pos = .GlobalEnv)
      
      whichPars <- best_parvec[[i]][setdiff(names(best_parvec[[i]]), names(fixed_pars)) ]
      assign("which_pars", whichPars, pos = .GlobalEnv)

      profile(obj = fit_obj, pars = which_pars, whichPar = names(which_pars), cores = ncores, fixed = fixed_pars, stepControl = list(stepsize = 1e-3, min = 1e-3, limit = 80), optControl = list(iterlim = 8))
    }))
}, machine = paste0("knecht", c(3)), filename = paste0("tmp_",tpaste0("profile_job_no_mohr_fix_error_pars")), input = "no_mohr.frame")
saveRDS(profile_job_no_mohr_fix_error_pars_bigger_stepsize, tpaste0("profile_job_no_mohr_fix_error_pars_bigger_stepsize.rds"))
```


## Get all three profiles
```{r, dependson="setup"}
load("2018_03_31_02_21_workspace_with_dMod.frames.rda")
no_mohr.frame <- readRDS("2018_04_01_20_34_fits_no_mohr_broad_sampling.rds") 

list(no_mohr.frame, apapbicmet.frame) %>% walk(. %>% .$obj %>% walk(loadDLL))

no_mohr.frame <- no_mohr.frame %>% dMf_expand_fits()
# profile_jobs <- c("2018_04_01_20_51_profile_job_no_mohr.rds", "2018_04_02_00_27_profile_job_no_mohr_fix_error_pars.rds", "2018_04_02_01_09_profile_job_no_mohr_fix_error_pars_bigger_stepsize.rds")
# 
# profile.frame <- map(profile_jobs, function(i) {
#   myjob <- readRDS(i)
#   myframe <- myjob$get()[[1]]
# })
# profile.frame <- profile.frame %>% do.call(rbind,.)
# saveRDS(profile.frame, tpaste0("profile.frame_no_mohr.rds"))

profile.frame <- readRDS("2018_04_02_10_35_profile.frame_no_mohr.rds")
```


The profiles are wiggly, but it helps to increase the minimum stepsize.
What does this wiggling mean? That there are several really closely located optima? I doubt that.
Maybe I could try to run profiles with "optimize"?

Description of the profiles:
awesome: klu_exco2 and offset_bic 
identifiable: Co2fix_Hlm_cl, cyp1a2met_cl, ka_metc13 and kbo_maxco2.
probably idfy, but profile stopped: apapd_hlm_cl, apapkm_apap and ka_co2c13
flat: cyp1a2_km_met, kbo_relco2, errorpars
```{r}
profile.frame$profiles %>% .[3] %>%  map(plotProfile) %>% .[[1]] +geom_smooth()
```


Seems as if KBO_RELCO2 and KBO_FIXCO2 are dependent on each other
Also, CYP1A2_KM_MET appears to change always, but since this parameter is so small anyway, I'll just fix it in the next profiles.
```{r}
profile.frame$profiles  %>% .[1] %>% map(. %>% plotPaths(whichPar =11))
```


## start some more profiles with more fixed pars
Fix CYP1A2MET_KM_MET and KBO_FIXCO2
```{r start profiles with more fixed pars}
# profile_job_no_mohr_fix_more_pars <- runbg({
#   ncores <- detectFreeCores()
#   assign("ncores", ncores, pos = .GlobalEnv)
#   
#   
#   
#   no_mohr.frame %>%
#     mutate(hypothesis = "No albert_caps and mohr, Profiles with fixed error pars") %>% 
#     mutate(profiles = map(seq_along(x), function(i) {
#       assign("fit_obj", obj[[i]], pos = .GlobalEnv)
#       assign("fit_pars", best_parvec[[i]], pos = .GlobalEnv)
#       
#       fixedPars <- best_parvec[[i]] %>% .[str_detect(names(.),"^S")] 
#       fixedPars <- c(fixedPars, best_parvec[[i]][c("KBO_FIXCO2", "CYP1A2MET_KM_MET")])
#       assign("fixed_pars", fixedPars, pos = .GlobalEnv)
#       
#       whichPars <- best_parvec[[i]][setdiff(names(best_parvec[[i]]), names(fixed_pars)) ]
#       assign("which_pars", whichPars, pos = .GlobalEnv)
# 
#       profile(obj = fit_obj, pars = which_pars, whichPar = names(which_pars), cores = ncores, fixed = fixed_pars)
#     }))
# }, machine = paste0("knecht", c(2)), filename = paste0("tmp_",tpaste0("profile_job_no_mohr_fix_error_pars")), input = "no_mohr.frame")
# saveRDS(profile_job_no_mohr_fix_more_pars, tpaste0("profile_job_no_mohr_fix_more_pars.rds"))

# profile_job_no_mohr_fix_more_pars <- readRDS("2018_04_02_11_11_profile_job_no_mohr_fix_more_pars.rds")
# profile.frame <- rbind(profile.frame, profile_job_no_mohr_fix_more_pars$get()[[1]])
# profile.frame$hypothesis[4] <- "No_mohr, fix errorpars, KBO_FIXCO2 and CYP1A2MET_KM_MET"
# profile.frame %>% saveRDS(tpaste0("profile.frame.rds"))

profile.frame <- readRDS("2018_04_02_19_40_profile.frame.rds")
```



```{r}
profile.frame$profiles %>% .[[4]] %>% plotProfile()
```



# Fit with prior around pars_raw, srel = -1, s0 = -2
```{r, dependson="setup"}
load("2018_03_31_02_21_workspace_with_dMod.frames.rda")
no_mohr.frame <- readRDS("2018_04_01_20_34_fits_no_mohr_broad_sampling.rds")

rbind(bicmet.frame, apapbicmet.frame) %>% .$obj %>% walk(loadDLL)
no_mohr.frame %>% .$obj %>% walk(loadDLL)
no_mohr.frame <- no_mohr.frame %>% dMf_expand_fits()
```

```{r fix errorpars}
s0 <- paste(c("S0"), c("CUM_REC_METC13", "DOB", "P_CO2F"), sep = "_")
srel <- paste(c("SREL"), c("CUM_REC_METC13", "DOB", "P_CO2F"), sep = "_")
trafo_sigma_set <- trafo_apapbicmet_sigma_NA %>% 
  insert("x~-1", x = srel) %>% 
  insert("x~-2", x = s0)

p_sig <- P(trafo_sigma_set, modelname = "p_apapbicmet_sigma_set", compile = F)
compile(p_sig, output = "p_apapbicmet_sigma_set")
```

```{r setup prior}
getParameters(p_sig)

myindices <- pars_raw %>% names %>% toupper() %>% {which(. %in% getParameters(p_sig))}

prior_mu <- log(pars_raw[myindices])
names(prior_mu) <- toupper(names(prior_mu))

```

```{r setup prior.frame}
prior.frame <- apapbicmet.frame
prior.frame[["hypothesis"]] <- "srel = -1,s0=-2, prior_sigma ="

prior.frame[["p_sig"]] <- list(p_sig)

prior.frame <- prior.frame %>% 
  mutate(data_0 = map(data_0, . %>% 
                        .[!((names(.) %>% str_detect("lbert")) & (names(.) %>% str_detect("caps")))] %>% 
                        .[!(names(.) %>% str_detect("Mohr"))])) %>% 
  mutate(prd_0 = map(seq_along(x), function(i) cfn(g[[i]], cfn(x[[i]],p_0[[i]]))),
         prd_sig = map(seq_along(x), function(i) cfn(g[[i]], cfn(x[[i]],p_sig[[i]])))) %>% 
  mutate(obj_0 = map(seq_along(x), function(i) normL2(data_0[[i]], prd_0[[i]])),
         obj_sig = map(seq_along(x), function(i) cf_normL2(data = data_sig[[i]], prd_sig[[i]], e = e[[i]]))) %>% 
  
  mutate(obj = map(seq_along(x), function(i) obj_sig[[i]]+obj_0[[i]])) %>% 
  mutate(prd = map(seq_along(x), function(i) prd_sig[[i]]+prd_0[[i]])) %>% 
  mutate(data= map(seq_along(x), function(i) data_sig[[i]]+data_0[[i]])) 
  

prior.frame <- rbind(prior.frame, prior.frame, prior.frame, prior.frame) %>% 
  mutate(obj = map(seq_along(x), function(i) {
    {obj[[i]] + constraintL2(prior_mu, sigma = 10^(i-4))}
  })) %>% 
  mutate(hypothesis = map_chr(1:4, function(i) paste0(hypothesis[i], 10^(i-4))))
prior.frame[["pars"]] <- map(1:4, function(i) c(prior_mu, offset_bic = -0.011))
```

```{r test objfn}
# prior.frame %>% mutate(test = map(seq_along(x), function(i) getParameters(obj[[i]]))) %>% .$test

prior.frame %>% mutate(test = map(seq_along(x), function(i) obj[[i]](getParameters(obj[[i]]) %>% are_names_of(0)))) %>% .$test
prior.frame %>% mutate(test = map(seq_along(x), function(i)  obj[[i]](pars[[i]]))) %>% .$test

```

```{r start fits}
fit_with_prior <- runbg({
  ncores <- detectFreeCores()
  assign("ncores", ncores, pos = .GlobalEnv)

  prior.frame %>%
    
    mutate(fits = map(seq_along(x), function(i) {
      assign("fit_obj", obj[[i]], pos = .GlobalEnv)
      assign("fit_pars", pars[[i]], pos = .GlobalEnv)
      assign("fit_studyname", paste0("fits", hypothesis[[i]]), pos = .GlobalEnv)
      mstrust(objfun = fit_obj, center = fit_pars, studyname = fit_studyname,
              sd = 3,
              blather = F, cores = ncores, fits = 10*ncores)
    }))
  }, machine = paste0("knecht", 1:5), filename = paste0("tmp_",tpaste0("fit_with_prior")), input = "prior.frame")

saveRDS(fit_with_prior, tpaste0("fit_with_prior.rds"))
```

```{r}
# bla <- fit_with_prior$get()

```

```{r}
# myfits <- bla %>% map("fits") %>% .[c(1,2,3,5)] %>% transpose() %>% map(. %>% Reduce(c.parlist,.))
# 
# prior.frame[["fits"]] <- myfits
# saveRDS(prior.frame, tpaste0("prior.frame.rds"))
prior.frame <- readRDS("2018_04_02_22_37_prior.frame.rds")
```
```{r}
prior.frame <- prior.frame %>% dMf_expand_fits() %>% dMf_append_plots()
```

```{r}
prior.frame$plot_value

prior.frame$parframes %>% map(. %>% .[1:600]) %>% map(plotValues,tol = 10)
```


```{r dMf_append_plots}
dMf_append_plots <- function(mydMod.frame, tol = 1, ...) {

  message("Please write down what you see")

  # Append waterfall, pars, and prediction of the best fit
  mydMod.frame <- mydMod.frame %>%
    
    mutate(best_prediction = map(seq_along(x), function(i) {
      prd[[i]](times = seq(0, max(as.data.frame(data[[i]])$time),length.out = 100),
               pars = best_parvec[[i]],
               deriv = F)
      })) %>% 
    
    mutate(plot_value = map(parframes, plotValues, tol = tol),
           plot_pars = map(parframes, plotPars, tol = tol),
           plot_combined = map(seq_along(x), function(i) plotCombined(best_prediction[[i]], data[[i]],...))) %>%
    mutate(plot_value = map(seq_along(x), function(i) plot_value[[i]] + ggtitle(label = paste(hypothesis[[i]], ",\t", best_value[[i]]))),
           plot_pars = map(seq_along(x), function(i) plot_pars[[i]] + ggtitle(label = paste(hypothesis[[i]], ",\t", best_value[[i]]))),
           plot_combined = map(seq_along(x), function(i) plot_combined[[i]] + ggtitle(label = paste(hypothesis[[i]], ",\t", best_value[[i]]))))

  # Adjust labels
  if ("conditions" %in% names(mydMod.frame)) {
    mydMod.frame <- mydMod.frame %>%
      mutate(plot_combined = map(seq_along(x), function(i) plot_combined[[i]] + scale_color_dMod(labels = conditions[[i]])))
  }

  return(mydMod.frame)
}

```


```{r}
prior.frame %>% dMf_append_plots(tol  = 10, name %in% names(observables_bic)&(condition %in% names(rbind(data_bic,data_bic_sigma_NA) %>% as.datalist))) %>% .$plot_combined
```

## Run profiles for the prior.frame

```{r}
profile_jobs_prior <- map(1:4, function(j) {
  assign("myframe",  prior.frame[j,], pos = .GlobalEnv)
  runbg({
    ncores <- detectFreeCores()
    assign("ncores", ncores, pos = .GlobalEnv)
    
    myframe %>%
      mutate(profiles = map(seq_along(x), function(i) {
        assign("fit_obj", obj[[i]], pos = .GlobalEnv)
        assign("fit_pars", best_parvec[[i]], pos = .GlobalEnv)
        
        profile(obj = fit_obj, pars = fit_pars, whichPar = names(fit_pars), cores = ncores)
      }))
  }, machine = paste0("knecht", c(j)), filename = paste0("tmp_",tpaste0("profile_jobs_prior")), input = "myframe")
})

 saveRDS(profile_jobs_prior, tpaste0("profile_jobs_prior.rds"))

# profile_job_no_mohr_fix_more_pars <- readRDS("2018_04_02_11_11_profile_job_no_mohr_fix_more_pars.rds")
# profile.frame <- rbind(profile.frame, profile_job_no_mohr_fix_more_pars$get()[[1]])
# profile.frame$hypothesis[4] <- "No_mohr, fix errorpars, KBO_FIXCO2 and CYP1A2MET_KM_MET"
# profile.frame %>% saveRDS(tpaste0("profile.frame.rds"))
```

```{r}
bla <- profile_jobs_prior[[2]]$get()

bla[[1]]$profiles %>% plotProfile() + coord_cartesian(ylim = c(-0.2, 4))
```


