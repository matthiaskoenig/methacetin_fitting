---
title: "Fitting model 41"
output: 
  html_document:
    toc: TRUE
---


Load all important libraries
```{r setup, message=FALSE, warning=FALSE, eval=TRUE, echo=FALSE}
knitr::opts_chunk$set(eval = TRUE)
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(fig.height = 10)
knitr::opts_chunk$set(fig.width = 15)
library(dMod)
# library(stringr) # Um bequem mit strings zu arbeiten
# library(tidyverse) # Viele Funktionen, u.a. für data.frames und ggplot2 für schöne plots
# library(magrittr) # der Pipe-operator %>%: z.B: x =" a; y="f(x); z="g(y); wird zu z=" a %>% f %>% g
library(conveniencefunctions)

```


# Read model
```{r read_model, dependson="setup"}
source("../model/limax_pkpd_v41.R")
```


```{r pars_raw, dependson="read_model"}
pars_raw <- c(x0, p) 
pars_in_dxdtdmod <- c(getSymbols(dxdt_dmod), names(dxdt_dmod))
```


# Data - read and preprocess
Read data, insert the default values for the parameters supplied in the data sheet. 

* Taheri rausschmeißen zum Fitten: Wird weiter unten getan

```{r, message=FALSE}
# Read data
data_full <-
  read_tsv("../data/limax_pkpd_v41_data.csv") %>%
  select(-model) %>% 
  rename(name = observer) %>% 
  rename(n = subjects) %>% 
  unique() #noch matthias sagen, dass lalazar2008 doppelte einträge hat

# For those studies where some data points have no sigma, infer it from the other sigmas of the same study
fitErrorModel_factors <- c("study", "group", "name", "BW", "PODOSE_apap", "IVDOSE_apap", 
"PODOSE_co2c13", "IVDOSE_co2c13", "Ri_co2c13", "ti_co2c13", "PODOSE_metc13", 
"IVDOSE_metc13", "ti_metc13")
some_na <-
  data_full %>% 
  group_by(study, group, name) %>% 
  mutate(nna = n(), sna = sum(is.na(sigma))) %>% 
  filter(sna>0 & sna != nna) %>% 
  select(-sna, -nna) %>% 
  as.data.frame() %>% 
  fitErrorModel(factors = fitErrorModel_factors, plotting = F, blather = F) 

none_or_all_na <- data_full %>% 
  group_by(study, group, name) %>% 
  mutate(nna = n(), sna = sum(is.na(sigma))) %>% 
  filter(sna==0 | sna == nna) %>% 
  select(-sna, -nna) %>% 
  as.data.frame()

data_full <- rbind(some_na, none_or_all_na) %>% 
  select(-n)

```

# Set up the model

```{r setup model independently of the individual setups}
# Parameters to fit by Matthias
free_pars_apap <- c("Ka_apap", "APAPD_HLM_CL", "APAPD_Km_apap")
free_pars_bic <- c("Ka_co2c13", "KLU_EXCO2", "CO2FIX_HLM_CL", "KBO_FIXCO2", "KBO_RELCO2", "KBO_MAXCO2")
free_pars_met <- c("Ka_metc13", "CYP1A2MET_CL", "CYP1A2MET_Km_met")

# Observables
observables_apap <- y_dmod[c("Mve_apap")] %>% set_names(c("Mve_apap"))

recovery_bic <- paste(y_dmod["Exhalation_co2c13"], "/ 60 * Mr_co2c13 / Ri_co2c13 * 100")
observables_bic <- c(recovery_bic, y_dmod[c("DOB", "P_CO2Fc13")])
names(observables_bic) <- c("cum_rec_co2c13", "DOB", "P_CO2F")
observables_bic["P_CO2F"] <- paste0(observables_bic["P_CO2F"], " + offset_bic")

recovery_met <- paste(y_dmod["Exhalation_co2c13"], "/ init_PODOSE_metc13 * Mr_metc13 * 100" )
cum_met <- paste( "Abreath_co2c13/ init_PODOSE_metc13 * Mr_metc13 * 100")
observables_met <- c(recovery_met, cum_met) %>% set_names(c("mom_rec_metc13", "cum_rec_metc13"))

# Error models
errors_bic_sigma_NA <- paste0("sqrt(s0_", names(observables_bic), "^2 + srel_", names(observables_bic), "^2 * ", names(observables_bic), "^2 )") %>% set_names(names(observables_bic))
errors_bic_sigma_NA["cum_rec_co2c13"] <- 1 #hierfür gibts eh keine daten und ich weiß nicht, ob ich es einfach weglassen kann

errors_met_sigma_NA <- paste0("sqrt(s0_", names(observables_met), "^2 + srel_", names(observables_met), "^2 * ", names(observables_met), "^2)") %>% set_names(names(observables_met))
errors_met_sigma_NA["mom_rec_metc13"] <- 1 #hierfür gibts eh keine daten mit sigma=NA
```

```{r x g and e apapbicmet}
free_pars <- c(free_pars_apap, free_pars_bic, free_pars_met)
myodemodel <- odemodel(dxdt_dmod, modelname = "odemodel", fixed = setdiff(pars_in_dxdtdmod, c(free_pars, "Aar_apap"))) # Aar_apap is not there to be optimized, but a variable which is a state is needed because of a bug in odemodel.
x <- Xs(myodemodel)

g <- Y(c(observables_apap, observables_bic, observables_met), x, attach.input = F, modelname = "g", compile = F)
compile(g, output = "g")

e_sigma_NA <- Y(c(errors_bic_sigma_NA, errors_met_sigma_NA), g)#, modelname = "e", compile = F) #cant cope with NaNs passed to it, if compiled
```

```{r data and p apapbicmet}
# Remove certain studies from the data which goes into fitting
data_for_fitting <- data_full %>% 
  filter(!str_detect(simulation, "limax")) %>% 
  filter(!str_detect(study, "Mohr2018")) %>% 
  filter(!(str_detect(study, "Albert")&str_detect(group, "capsule")))

# Split the data in datasets with and without sigma
data <- data_for_fitting  %>% filter(!is.na(sigma)) %>% select(-simulation)
data_sigma_NA <- data_for_fitting  %>% filter(is.na(sigma)) %>% select(-simulation)

# Get all parameters that in some way replace pars_raw (parameters supplied by the SBML file) or are additional parameters that we need to fit
# This could be e.g. Study specific pars such as IVDOSE* or pars that are fitted
supplied_pars <- names(pars_raw)[(names(pars_raw) %in% names(data))]
outer_pars <- sort(unique(c(free_pars, supplied_pars)))

pars_errors <- c(errors_bic_sigma_NA, errors_met_sigma_NA) %>% 
  getSymbols %>% 
  str_subset("^s") %>% 
  are_names_of(1)
outer_pars_sigma_NA <- sort(unique(c(outer_pars, names(pars_errors))))

# Define the parameter trafos which in turn define the different conditions
trafo <-
  c(pars_raw) %>% 
  sort_by_name() %>% 
  replace(names(.) %in% outer_pars, outer_pars) %>% 
  
  branch(data %>% as.datalist() %>% covariates()) %>% # The table of covariates includes dosepar and dose, which are used in the next line
  
  insert("name ~ value", value = unlist(mget(supplied_pars)), name = supplied_pars) %>% # insert parameters supplied by the data

  define("init_PODOSE_metc13~podose", podose = mytrafo[[i]]["PODOSE_metc13"]) %>% # For the observables, I need the initial dose as a fixed parameter which doesn't change. Because the PODOSE_metc13 is also a state, I need to duplicate this parameters
  
  insert("x~exp(X)", x = getSymbols(mytrafo[[i]]), X = toupper(getSymbols(mytrafo[[i]]))) %>% 
  
  define("x~x", x = "offset_bic")




trafo_sigma_NA <-
  c(pars_raw, pars_errors) %>% 
  sort_by_name() %>% 
  replace(names(.) %in% outer_pars_sigma_NA, outer_pars_sigma_NA) %>%
  
  branch(data_sigma_NA %>% as.datalist() %>% covariates()) %>% # The table of covariates includes dosepar and dose, which are used in the next line
  insert("name ~ value", value = unlist(mget(supplied_pars)), name = supplied_pars) %>%

  define("init_PODOSE_metc13~podose", podose = mytrafo[[i]]["PODOSE_metc13"]) %>% # For the observables, I need the initial dose as a fixed parameter which doesn't change. Because the PODOSE_metc13 is also a state, I need to duplicate this parameters
  
  insert("x~exp(X)", x = getSymbols(mytrafo[[i]]), X = toupper(getSymbols(mytrafo[[i]]))) %>% 
  
  insert("x~-2", x = str_subset(getSymbols(mytrafo[[i]]), "^S0")) %>% # Fix the error parameters to a value
  insert("x~-1", x = str_subset(getSymbols(mytrafo[[i]]), "^SREL")) %>% 
  
  define("x~x", x = "offset_bic") 


p <- P(trafo, modelname = "p", compile = F)
pars <- getParameters(p) %>% are_names_of(0)

p_sigma_NA <- P(trafo_sigma_NA, modelname = "p_sig", compile = F)
pars_sigma_NA <- getParameters(p_sigma_NA) %>% are_names_of(0)


compile(p, p_sigma_NA, cores = 3, output = "p")
```


# dMod.frames

```{r initialize dMod_frames }
# remove(data)
apapbicmet_frame <- dMod.frame(
  hypothesis = "No Mohr, Albert Caps, Taheri.",
  x = x,
  g = g,
  p = p,
  data = data,
  e = NULL,
  x_sig = x,
  g_sig = g,
  p_sig = list(p_sigma_NA),
  e_sig = list(e_sigma_NA),
  data_sig = list(as.datalist(data_sigma_NA))
)

apapbicmet_frame <- apapbicmet_frame %>% 
  rowwise() %>% 
  appendObj() %>% 
  mutate(prd_sig = list(g_sig * x_sig * p_sig), 
         obj_data_sig = list(normL2(data_sig, prd_sig, e_sig)),
         obj = list(obj_data+ obj_data_sig),
         pars = list(structure(rnorm(length(getParameters(obj))), names =  getParameters(obj))), 
         times = list(seq(min(rbind(as.data.frame(data),as.data.frame(data_sig))[["time"]]), 
                          max(rbind(as.data.frame(data),as.data.frame(data_sig))[["time"]]) * 1.1, 
                          length.out = 200))) %>% 
  mutate(prd_data = list(prd),
         prd = list(prd_data+prd_sig), 
         desciption = "The problem with the need to split up both datasets makes the dMod.frame less tidy.
         Especially, prd_data refers to only the data with sigmas, whereas prd refers to the sum of prd_0 and prd_sig.")

git_add_dMod.frame(apapbicmet_frame)
remove_c_and_o()
```




# Fit with prior around pars_raw, srel = -1, s0 = -2
```{r, dependson="setup"}
# load("2018_04_23_16_57_workspace_with_dMod.frames.rda")
# apapbicmet_frame %>% .$obj %>% walk(loadDLL)
```

```{r fix errorpars}
# s0 <- paste(c("S0"), c("CUM_REC_METC13", "DOB", "P_CO2F"), sep = "_")
# srel <- paste(c("SREL"), c("CUM_REC_METC13", "DOB", "P_CO2F"), sep = "_")
# trafo_sigma_set <- trafo_apapbicmet_sigma_NA %>% 
#   insert("x~-1", x = srel) %>% 
#   insert("x~-2", x = s0)
# 
# p_sig <- P(trafo_sigma_set, modelname = "p_apapbicmet_sigma_set", compile = F)
# compile(p_sig, output = "p_apapbicmet_sigma_set")
# ```
# 
# ```{r setup prior}
# getParameters(p_sig)
# 
# myindices <- pars_raw %>% names %>% toupper() %>% {which(. %in% getParameters(p_sig))}
# 
# prior_mu <- log(pars_raw[myindices])
# names(prior_mu) <- toupper(names(prior_mu))

```

```{r setup prior_frame}
# prior_frame <- apapbicmet_frame
# prior_frame[["hypothesis"]] <- "srel = -1,s0=-2, prior_sigma ="
# 
# prior_frame[["p_sig"]] <- list(p_sig)
# 
# prior_frame <- prior_frame %>% 
#   mutate(data_0 = map(data_0, . %>% 
#                         .[!((names(.) %>% str_detect("lbert")) & (names(.) %>% str_detect("caps")))] %>% 
#                         .[!(names(.) %>% str_detect("Mohr"))])) %>% 
#   mutate(prd_0 = map(seq_along(x), function(i) cfn(g[[i]], cfn(x[[i]],p_0[[i]]))),
#          prd_sig = map(seq_along(x), function(i) cfn(g[[i]], cfn(x[[i]],p_sig[[i]])))) %>% 
#   mutate(obj_0 = map(seq_along(x), function(i) normL2(data_0[[i]], prd_0[[i]])),
#          obj_sig = map(seq_along(x), function(i) cf_normL2(data = data_sig[[i]], prd_sig[[i]], e = e[[i]]))) %>% 
#   
#   mutate(obj = map(seq_along(x), function(i) obj_sig[[i]]+obj_0[[i]])) %>% 
#   mutate(prd = map(seq_along(x), function(i) prd_sig[[i]]+prd_0[[i]])) %>% 
#   mutate(data= map(seq_along(x), function(i) data_sig[[i]]+data_0[[i]])) 
#   
# 
# prior_frame <- rbind(prior_frame, prior_frame, prior_frame, prior_frame) %>% 
#   mutate(obj_data = obj) %>% 
#   mutate(constr = map(seq_along(x), function(i) {
#     {constraintL2(prior_mu, sigma = 10^(i-4))}
#   })) %>% 
#   mutate(obj = map(seq_along(x), function(i) {
#     obj_data[[i]]+constr[[i]]
#   })) %>% 
#   mutate(hypothesis = map_chr(1:4, function(i) paste0(hypothesis[i], 10^(i-4))))
# prior_frame[["pars"]] <- map(1:4, function(i) c(prior_mu, offset_bic = -0.011))
```

```{r test objfn}
# prior_frame %>% mutate(test = map(seq_along(x), function(i) getParameters(obj[[i]]))) %>% .$test

# # prior_frame %>% mutate(test = map(seq_along(x), function(i) obj[[i]](getParameters(obj[[i]]) %>% are_names_of(0)))) %>% .$test
# prior_frame %>% mutate(test = map(seq_along(x), function(i)  obj[[i]](pars[[i]]))) %>% .$test %>% page
# 
# prior_frame %>% mutate(test = map(seq_along(x), function(i)  obj_data[[i]](pars[[i]]))) %>% .$test %>% page
# 
# prior_frame %>% mutate(test = map(seq_along(x), function(i)  constr[[i]](pars[[i]]))) %>% .$test %>% page

```

```{r start and retrieve fits}
# fit_with_prior <- runbg({
#   ncores <- detectFreeCores()
#   assign("ncores", ncores, pos = .GlobalEnv)
# 
#   prior_frame %>%
#     
#     mutate(fits = map(seq_along(x), function(i) {
#       assign("fit_obj", obj[[i]], pos = .GlobalEnv)
#       assign("fit_pars", pars[[i]], pos = .GlobalEnv)
#       assign("fit_studyname", paste0("fits", hypothesis[[i]]), pos = .GlobalEnv)
#       mstrust(objfun = fit_obj, center = fit_pars, studyname = fit_studyname,
#               sd = 3,
#               blather = F, cores = ncores, fits = 10*ncores)
#     }))
#   }, machine = paste0("knecht", 1:5), filename = paste0("tmp_",tpaste0("fit_with_prior")), input = "prior_frame")
# 
# saveRDS(fit_with_prior, tpaste0("fit_with_prior.rds"))
# fit_with_prior <- fit_with_prior$get()
# myfits <- fit_with_prior %>% map("fits") %>% .[c(1,2,3,5)] %>% transpose() %>% map(. %>% Reduce(c.parlist,.))
# prior_frame[["fits"]] <- myfits
# saveRDS(prior_frame, tpaste0("prior_frame.rds")) # "2018_04_02_22_37_prior_frame.rds"
# 
# prior_frame <- readRDS("2018_04_02_22_37_prior_frame.rds")
# ```
# 
# ```{r}
# prior_frame <- prior_frame %>% dMf_expand_fits() %>% dMf_append_plots()
# ```
# 
# ```{r}
# prior_frame$plot_value
# prior_frame$parframes %>% map(. %>% .[1:600]) %>% map(plotValues,tol = 10)
# ```
# 
# ```{r}
# prior_frame %>% dMf_append_plots(tol  = 10, name %in% names(observables_bic)&(condition %in% names(rbind(data_bic,data_bic_sigma_NA) %>% as.datalist))) %>% .$plot_combined
```

## Run profiles for the prior_frame

```{r start and retrieve profiles for prior_frame}
# profile_jobs_prior <- map(1:4, function(j) {
#   assign("myframe",  prior_frame[j,], pos = .GlobalEnv)
#   runbg({
#     ncores <- detectFreeCores()
#     assign("ncores", ncores, pos = .GlobalEnv)
#     
#     myframe %>%
#       mutate(profiles = map(seq_along(x), function(i) {
#         assign("fit_obj", obj[[i]], pos = .GlobalEnv)
#         assign("fit_pars", best_parvec[[i]], pos = .GlobalEnv)
#         
#         profile(obj = fit_obj, pars = fit_pars, whichPar = names(fit_pars), cores = ncores)
#       }))
#   }, machine = paste0("knecht", c(j)), filename = paste0("tmp_",tpaste0("profile_jobs_prior")), input = "myframe")
# })
# 
#  saveRDS(profile_jobs_prior, tpaste0("profile_jobs_prior.rds"))
# profile_jobs_prior <- readRDS("2018_04_02_23_22_profile_jobs_prior.rds")
# prior_frame <- profile_jobs_prior %>% map(. %>% {.$get()} %>% .[[1]]) %>% do.call(rbind,.)
# saveRDS(prior_frame %>% shrink_fits() %>% shrink_plots(), tpaste0("prior_frame_with_profiles.rds")) # "2018_04_06_13_50_prior_frame_with_profiles.rds"
# prior_frame <- readRDS("2018_04_06_13_50_prior_frame_with_profiles.rds")
```



Looking at the profiles, some of the parameters are really far off their original values, whereas many can be determined quite well from the data.

Prior were good guesses for
  KA_APAP, offset_bic

APAPD_HLM_CL, APAPD_KM_APAP, CO2FIX_HLM_CL, CYP1A2MET_CL, 
    CYP1A2MET_KM_MET, , KA_CO2C13, KA_METC13, KBO_FIXCO2, 
    KBO_MAXCO2, KBO_RELCO2, KLU_EXCO2, offset_bic

I think, data is contributing enough for the following parameters, so the prior is not needed for them anymore
  APAPD_HLM_CL, APAPD_KM_APAP, KA_APAP



```{r}
# prior_frame$obj[[1]] %>% getParameters() %>% map(as.name) %>% unlist %>% dput
```


```{r}
# prior_frame$profiles %>% 
#   plotProfile() + 
#   coord_cartesian(ylim = c(-2, 4))
```

No comment on the paths yet.
```{r}
# prior_frame$profiles %>% plotPaths(whichPar = "KBO_FIXCO2")
```

The plotCombined looks much better with weaker priors!
```{r}
# prior_frame$obj %>% walk(loadDLL)
# prior_frame %>% plotCombined.dMod.frame(hypothesis = 4)
# map(1:4, . %>% plotCombined.dMod.frame(prior_frame, hypothesis = .))
```


# Run one fit with weak prior
```{r, dependson="setup"}
# load("2018_03_31_02_21_workspace_with_dMod.frames.rda")
# 
# rbind(bicmet_frame, apapbicmet_frame) %>% .$obj %>% walk(loadDLL)
```


```{r setup prior_frame_weak}
# prior_frame_weak <- apapbicmet_frame
# prior_frame_weak[["hypothesis"]] <- "srel = -1,s0=-2, prior_sigma ="
# 
# prior_frame_weak[["p_sig"]] <- list(p_sig)
# 
# prior_frame_weak <- prior_frame_weak %>%
#   mutate(data_0 = map(data_0, . %>%
#                         .[!((names(.) %>% str_detect("lbert")) & (names(.) %>% str_detect("caps")))] %>%
#                         .[!(names(.) %>% str_detect("Mohr"))])) %>%
#   mutate(prd_0 = map(seq_along(x), function(i) cfn(g[[i]], cfn(x[[i]],p_0[[i]]))),
#          prd_sig = map(seq_along(x), function(i) cfn(g[[i]], cfn(x[[i]],p_sig[[i]])))) %>%
#   mutate(obj_0 = map(seq_along(x), function(i) normL2(data_0[[i]], prd_0[[i]])),
#          obj_sig = map(seq_along(x), function(i) cf_normL2(data = data_sig[[i]], prd_sig[[i]], e = e[[i]]))) %>%
# 
#   mutate(obj = map(seq_along(x), function(i) obj_sig[[i]]+obj_0[[i]])) %>%
#   mutate(prd = map(seq_along(x), function(i) prd_sig[[i]]+prd_0[[i]])) %>%
#   mutate(data= map(seq_along(x), function(i) data_sig[[i]]+data_0[[i]]))
# 
# 
# prior_frame_weak <- rbind(prior_frame_weak, prior_frame_weak) %>%
#   mutate(obj_data = obj) %>%
#   mutate(constr = map(seq_along(x), function(i) {
#     {constraintL2(prior_mu, sigma = i*5)}
#   })) %>%
#   mutate(obj = map(seq_along(x), function(i) {
#     obj_data[[i]]+constr[[i]]
#   })) %>%
#   mutate(hypothesis = map_chr(c(1:2), function(i) paste0(hypothesis[i], i*5)))
# prior_frame_weak[["pars"]] <- map(1:2, function(i) c(prior_mu, offset_bic = -0.011))
```

```{r fit and profiles weak prior}
# fit_with_weaker_prior <- runbg({
#   ncores <- detectFreeCores()
#   assign("ncores", ncores, pos = .GlobalEnv)
#   
#   prior_frame_weak %>% 
#   mutate(fits = map(seq_along(x), function(i) {
#     assign("fit_obj", obj[[i]], pos = .GlobalEnv)
#     assign("fit_pars", pars[[i]], pos = .GlobalEnv)
#     assign("fit_studyname", paste0("fits", hypothesis[[i]]), pos = .GlobalEnv)
#     mstrust(objfun = fit_obj, center = fit_pars, studyname = fit_studyname,
#             sd = 3,
#             blather = F, cores = ncores, fits = 10*ncores)
#   }))
# },  machine = c(paste0("knecht", 3:4), paste0("ruprecht",1:2)), input = "prior_frame_weak", filename = "2018_04_12_18_28_fit_with_weaker_prior_runbg")
# saveRDS(fit_with_weaker_prior, file = "2018_04_12_18_28_fit_with_weaker_prior.rds")
# fit_with_weaker_prior <- readRDS("2018_04_12_18_28_fit_with_weaker_prior.rds")
# fit_with_weaker_prior$check()
# wait_for_runbg(fit_with_weaker_prior)
# fit_with_weaker_prior_results <- fit_with_weaker_prior$get()
# saveRDS(fit_with_weaker_prior_results, file = "2018_04_12_18_28_fit_with_weaker_prior_results.rds")
# fit_with_weaker_prior$purge()


# fit_with_weaker_prior <- readRDS("2018_04_12_18_28_fit_with_weaker_prior_results.rds")
# ```
# 
# ```{r}
# myfits <-
#   map(fit_with_weaker_prior, "fits") %>% 
#   transpose() %>% 
#   map(. %>% Reduce(c.parlist,.)) 
# prior_frame_weak <- fit_with_weaker_prior[[1]]
# prior_frame_weak$fits <- myfits
# ```
# 
# 
# ```{r}
# prior_frame_weak$obj %>% walk(loadDLL)
# prior_frame_weak <- prior_frame_weak %>% dMf_expand_fits() #%>% dMf_append_plots(index = 1:400)
# 
# prior_frame$obj %>% walk(loadDLL)
# prior_frame$prd <- map(1:4, function(i) prior_frame_weak$prd[[1]])
# prior_frame <- prior_frame %>% dMf_expand_fits() %>% dMf_append_plots()
# 
# ```
# 
# Seems as if there are some decent steps this time
# ```{r}
# prior_frame$plot_value
# prior_frame_weak %>% str1
# ```
# 

# ## profiles with weak prior
# ```{r}
# profiles_weak_prior_job <- runbg({
#     ncores <- detectFreeCores()
#     assign("ncores", ncores, pos = .GlobalEnv)
#   
#   prior_frame_weak %>%
#     mutate(profiles = map(seq_along(x), function(i) {
#       assign("fit_obj", obj[[i]], pos = .GlobalEnv)
#       assign("fit_pars", best_parvec[[i]], pos = .GlobalEnv)
#       
#       profile(obj = fit_obj, pars = fit_pars, whichPar = names(fit_pars), cores = ncores)
#     }))
# },  machine = c(paste0("ruprecht", 1)), input = "prior_frame_weak", filename = "2018_04_13_12_56_profiles_weak_prior_job_runbg")
# saveRDS(profiles_weak_prior_job, file = "2018_04_13_12_56_profiles_weak_prior_job.rds")
# profiles_weak_prior_job <- readRDS("2018_04_13_12_56_profiles_weak_prior_job.rds")
# profiles_weak_prior_job$check()
# wait_for_runbg(profiles_weak_prior_job, delta_t = 60)
# beepr::beep()
# profiles_weak_prior_job_results <- profiles_weak_prior_job$get()
# saveRDS(profiles_weak_prior_job_results, file = "2018_04_13_12_56_profiles_weak_prior_job_results.rds")
# profiles_weak_prior_job$purge()
# prior_frame_weak <- readRDS("2018_04_13_12_56_profiles_weak_prior_job_results.rds")$ruprecht1
```



# Reconcile fit results with new .c-files
I had the trouble that there was a random string attached to the function names in the .c-files, so when I let the script run again, these changed and the saved objects couldn't find their functions anymore in the DLLs. This is now fixed
```{r}
# prior_frame_old <- readRDS("2018_04_06_13_50_prior_frame_with_profiles.rds")
# prior_frame <- prior_frame %>%
#   add_column(parframes = prior_frame_old$parframes,
#              profiles = prior_frame_old$profiles)
# 
# prior_frame_weak_old <- readRDS("2018_04_13_12_56_profiles_weak_prior_job_results.rds")$ruprecht1
# prior_frame_weak <- prior_frame_weak %>%
#   add_column(parframes = prior_frame_weak_old$parframes,
#     profiles = prior_frame_weak_old$profiles)
# 
# saveRDS(rbind(prior_frame, prior_frame_weak), file = tpaste0("prior.frame_full.rds"))
# prior_frame <- readRDS("2018_04_23_17_00_prior.frame_full.rds")

```


# Look at results
```{r}
prior_frame <- readRDS("2018_04_23_17_00_prior.frame_full.rds")
prior_frame$obj %>% walk(loadDLL)
```


The profiles of the fits with weak prior are really bad and again slip into the trap with CYP1A2MET_KM_MET going to zero.
This again results in the profiles being wiggly and not reaching the limits.
Description of the profiles and further thoughts:
* Profiles for which I think the prior can definitely be removed:
    1. APAPD_HLM_CL
    1. APAP_KM_APAP
    1. KLU_EXCO2C13
```{r}
prior_frame$profiles %>% 
  plotProfile() +
  coord_cartesian(ylim = c(-2, 4)) +
  # scale_color_brewer() +
  geom_blank()
# ggplotly()
```


## Question: Which conditions push the parameter CYP1A2MET_KM_MET to -Inf?
```{r}
prior_frame <-
  prior_frame %>% 
  rowwise() %>% 
  mutate(condwise_data = list(obj_condition_wise(obj_data, parframes %>% as.parvec)),
         condwise_sum = list(obj_condition_wise(obj, parframes %>% as.parvec)),
         condwise_constr = list(obj_condition_wise(constr, parframes %>% as.parvec)))
```

Look at the conditions in hypothesis 4
```{r}
unnest_name <- function(myframe, unique = "condition", unnest_var = "gradient") {
  myframe_2 <- myframe %>% .[c(unique, unnest_var)]
  myframe_2 <- myframe_2 %>% apply(1, function(i) {
    tibble(condition = i[[unique]], grad_value = unlist(i[[unnest_var]]), grad_name = unlist(names(i[[unnest_var]])))
  }) %>% do.call(rbind,.)
  
  left_join(myframe, myframe_2)
}

prior_frame$condwise_data[[4]] %>% 
  do.call(rbind,.) %>% 
  unnest_name() %>% 
  ggplot(aes(y = grad_name, x = grad_value, color = condition)) + 
  geom_point()

# ggplotly()


git_add_dMod_frame("2018_04_23_17_00_prior.frame_full.rds")
```

```{r}
prior_frame$condwise_data[[4]] %>% 
  do.call(rbind,.) %>% 
  unnest_name() %>% 
  group_by(grad_name) %>%
  mutate(sum_val = sum(grad_value)) %>% 
  ggplot(aes(y = grad_name, x = sum_val, color = condition)) + 
  geom_point()
```

```{r}
prior_frame$condwise_sum[[4]] %>% 
  do.call(rbind,.) %>% 
  unnest_name() %>% 
  group_by(grad_name) %>%
  mutate(sum_val = sum(grad_value)) %>% 
  arrange(desc(sum_val), grad_name)
  ggplot(aes(y = grad_name, x = sum_val, color = condition)) + 
  geom_point() 
```

```{r}
prior_frame <- prior_frame %>% 
  mutate(val_sum = list(obj(parframes %>% as.parvec)),
         val_data = list(obj_data(parframes %>% as.parvec)),
         val_constr = list(constr(parframes %>% as.parvec)))
```

```{r}
prior_frame$val_sum[[4]]$gradient
```


```{r}
# myframe <- prior_frame$condwise[[4]] %>% 
#   do.call(rbind,.) 


unnest_name(myframe) %>% print


```











# Scan the prior range between 1 and 5
```{r dependson="pars_raw"}
apapbicmet_frame <- readRDS("2018_05_07_22_22_apapbicmet_frame.rds")
walk(apapbicmet_frame$obj, loadDLL)
myindices <- pars_raw %>% names %>% toupper() %>% {which(. %in% getParameters(apapbicmet_frame$p_sig[[1]]))}
prior_mu <- log(pars_raw[myindices])
names(prior_mu) <- toupper(names(prior_mu))

# prior_mu <- prior_mu %>% .[!names(prior_mu) %in% c("APAPD_HLM_CL", "APAPD_KM_APAP")]


prior_frame2 <- apapbicmet_frame %>% 
  rbind(.,.,.,.) %>% 
  ungroup() %>% 
  mutate(
    constr = map(seq_along(x), function(i) {
      constraintL2(prior_mu, sigma = i/2+1) }), 
    hypothesis = paste0("prior_sigma=", (1:4)/2+1)
  ) %>% 
  rowwise() %>% 
  mutate(obj = list(obj + constr)) %>% 
  {.}
```


```{r}
# fit_job <- runbg({
#     ncores <- detectFreeCores()
#     assign("ncores", ncores, pos = .GlobalEnv)
# 
#    prior_frame2 %>%
#     ungroup %>%
#     mutate(fits = map(seq_along(x), function(i) {
#       assign("fit_obj", obj[[i]], pos = .GlobalEnv)
#       assign("fit_pars", pars[[i]], pos = .GlobalEnv)
#       assign("fit_studyname", paste0("fits", hypothesis[[i]]), pos = .GlobalEnv)
#       mstrust(objfun = fit_obj, center = fit_pars, studyname = fit_studyname, sd = 3,
#              blather = F, cores = ncores, fits = 10*ncores) })) %>%
#     rowwise
# 
#   },  machine = c(paste0("knecht", c(1, 3,5)), "ruprecht1"), input = "prior_frame2", filename = "2018_05_07_22_49_fit_job_runbg")
# saveRDS(fit_job, file = "2018_05_07_22_49_fit_job.rds")
# fit_job <- readRDS("2018_05_07_22_49_fit_job.rds")
# fit_job$check()
# wait_for_runbg(fit_job)
# fit_job_results <- fit_job$get()
# saveRDS(fit_job_results, file = "2018_05_07_22_49_fit_job_results.rds")
# fit_job$purge()
# fit_job_results <- readRDS("2018_05_07_22_49_fit_job_results.rds")
```

```{r}
fit_job_results <- readRDS("2018_05_07_22_49_fit_job_results.rds")
prior_frame2 <- fit_job_results[[1]]
prior_frame2$fits <- fit_job_results %>% map("fits") %>% transpose() %>% map(. %>%  Reduce(c.parlist,.) )
prior_frame2 <- prior_frame2 %>% appendParframes()
```


```{r}
# computers <- c(paste0("ruprecht", c(1,2)), "ruprecht1", "fermi")
# profile_job <- map(seq_along(computers), function(i) {
#   myframe <- assign("myframe", prior_frame2[i, drop = F], pos = .GlobalEnv)
#   cat("job ", i, " starting. \n")
#   runbg({
#     ncores <- detectFreeCores()
#     assign("ncores", ncores, pos = .GlobalEnv)
# 
#    myframe %>%
#     ungroup %>%
#     mutate(profiles = map(seq_along(x), function(i) {
#       assign("fit_obj", obj[[i]], pos = .GlobalEnv)
#       assign("fit_pars", parframes[[i]] %>% as.parvec, pos = .GlobalEnv)
#       profile(obj = fit_obj, pars = fit_pars, whichPar = names(fit_pars), cores = ncores) })) %>%
#       rowwise
# 
#   },  machine = computers[i], input = "myframe", filename = paste0("2018_05_08_10_09_profile_job_runbg_", i), recover = T)
# })
# saveRDS(profile_job, file = "2018_05_08_10_09_profile_job.rds")
# profile_job <- map(seq_along(computers), function(i) recover_runbg(computers[i], paste0("2018_05_08_10_09_profile_job_runbg_", i)))
# beepr::beep()
# profile_job <- readRDS("2018_05_08_10_09_profile_job.rds")
# profile_job %>% walk(. %>% {.$check()})
# wait_for_runbg(profile_job)
# profile_job_results <- profile_job %>% map(. %>% {.$get()})%>% do.call(c,.) %>%  do.call(rbind,.)
# saveRDS(profile_job_results, file = "2018_05_08_10_09_profile_job_results.rds")
# profile_job %>% walk(. %>% {.$purge()})
prior_frame2 <- readRDS("2018_05_08_10_09_profile_job_results.rds")
```

```{r}
profile_job_results$profiles %>% setNames(profile_job_results$hypothesis) %>%  plotProfile()
```


# Reconcile prior_frame and prior_frame2
```{r}
prior_frame2 <- readRDS("2018_05_08_10_09_profile_job_results.rds")
prior_frame <- readRDS("2018_04_23_17_00_prior.frame_full.rds")
```


```{r}
names_old <- names(prior_frame)
names_new <- names(prior_frame2)
```

```{r}
names_old
```
```{r}
names_new
```


```{r}
prior_frame <- prior_frame %>% 
  select(-data, -obj_data) %>% 
  rename(g = g, x = x, p = p_0, data  = data_0, obj_data =  obj_0, prd_data = prd_0,
         p_sig = p_sig, obj_data_sig = obj_sig, e_sig = e) %>% 
  mutate(
    x_sig =x, g_sig = g, 
    
    times = list(seq(min(as.data.frame(data)[["time"]]),
                     max(as.data.frame(data)[["time"]]) * 1.1, length.out = 200)))


```

```{r}
bind_rows(prior_frame, prior_frame2)$profiles %>% setNames(bind_rows(prior_frame, prior_frame2)$hypothesis) %>%  plotProfile() +
  coord_cartesian(ylim = c(-0.5,4))


```



```{r}

reactions %>% 
  as.data.frame() %>% 
  filter(Rate %>% str_detect("KBO_RE"))

```











# Port dMod.frame to Shiny-App

Create reactions, a dMod-object which contains the stoichiometric matrix.
```{r, dependson="read_model"}
symbolic <- readr::read_lines("../model/limax_pkpd_v41.R", 649, 693-649)
mynames <- symbolic  %>%  str_split( "=", simplify = T) %>% .[,1] %>% str_replace_all(c(" "= "", "^ " = "", "^d" = ""))
equations <- symbolic  %>%  str_split( "=", simplify = T) %>% .[,2] %>% str_replace_all(c(" "= "", "^ " = "", "^d" = "", "," = ""))
ratenames <- getSymbols(c(equations)) %>% str_subset_not("^p")

S_preliminary <- outer(equations, ratenames, str_detect) # "Where do the reactions appear"?
S_negative <- outer(equations, paste0("\\-", ratenames), str_detect) # "Where do they appear with a negative sign"?
S <- (S_preliminary - 2 * S_negative) %>% t %>% magrittr::set_colnames(mynames)

rates <- y_dmod[ratenames]

reactions <- data.frame(Description = ratenames, Rate = rates, S, stringsAsFactors = F) %>% as.eqnlist()
```



```{r}
prior_frame <- readRDS("2018_04_23_17_00_prior.frame_full.rds")

prior_frame <- prior_frame %>% 
  mutate(reactions = map(seq_along(x), function(i) reactions)) %>% 
  mutate(sigma = str_replace(hypothesis, "srel = -1,s0=-2, prior_sigma =", ""))#%>% str_replace("\\.", ""))

walk(1:6, function(i) {
  saveShiny_dMod.frame(prior_frame, i, projectname = paste0("LiMaX", prior_frame$sigma[i]))
})
```











