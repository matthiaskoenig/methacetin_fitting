---
title: "methacetin-fitting"
author: "Daniel Lill"
date: "23 November 2017"
output:
  pdf_document: default
  html_document: default

---

Load all important libraries
```{r, message=FALSE, warning=FALSE}
library(dMod)
library(stringr) # Um bequem mit strings zu arbeiten
library(tidyverse) # Viele Funktionen, u.a. für data.frames und ggplot2 für schöne plots
library(magrittr) # der Pipe-operator %>%: z.B: x = a; y=f(x); z=g(y); wird zu z= a %>% f %>% g
library(conveniencefunctions)
library(libSBML)
```

# Model setup

## Read the model
This is basically copied from a libSBML-example
```{r}

filename <- "/home/denial/Promotion/Projects/methacetin_fitting/model/met13_pkpd_7.xml" # Attention: tilde expansion doesn't work
d <-  readSBML(filename)

m <- SBMLDocument_getModel(d)
# errors   = SBMLDocument_getNumErrors(d);
# SBMLDocument_printErrors(d);


level   = SBase_getLevel  (d);
version = SBase_getVersion(d);

cat("File: ",filename," (Level ",level,", version ",version,")\n");
cat("  model id: ", ifelse(Model_isSetId(m), Model_getId(m) ,"(empty)"),"\n");

cat( "functionDefinitions: ", Model_getNumFunctionDefinitions(m) ,"\n" );
cat( "    unitDefinitions: ", Model_getNumUnitDefinitions    (m) ,"\n" );
cat( "   compartmentTypes: ", Model_getNumCompartmentTypes   (m) ,"\n" );
cat( "        specieTypes: ", Model_getNumSpeciesTypes       (m) ,"\n" );
cat( "       compartments: ", Model_getNumCompartments       (m) ,"\n" );
cat( "            species: ", Model_getNumSpecies            (m) ,"\n" );
cat( "         parameters: ", Model_getNumParameters         (m) ,"\n" );
cat( " initialAssignments: ", Model_getNumInitialAssignments (m) ,"\n" );
cat( "              rules: ", Model_getNumRules              (m) ,"\n" );
cat( "        constraints: ", Model_getNumConstraints        (m) ,"\n" );
cat( "          reactions: ", Model_getNumReactions          (m) ,"\n" );
cat( "             events: ", Model_getNumEvents             (m) ,"\n" );
cat( "\n" );


```


### Einschub: der Pipe-Operator %>% 
```{r}
# Mit dem Pipe-Operator kann man Funktionen verketten
# Standardmäßig wird das vorherige Ergebnis als erstes Argument von der nächsten Funktion eingesetzt. wenn man das nicht will, kann man es als . woanders hinsetzen

f <- function(x) x^2;
g <- function(x,y) x-y;

2 %>% f # f(2)
2 %>% f %>% g(3) # g(f(2),3) = 4-3 = 1
2 %>% f %>% g(3,.) # g(3,f(2)) = 3-4 = -1

# Man kann auch Funktionen definieren, die mit . losgehen, was dann das Argument für die Funktion ist.
h <- . %>% sqrt %>% add(5)
h(4)
# Das ist besonders nützlich in lapply, sapply und so weiter, wo man über eine liste(oder einen vektor) immer wieder die gleiche funktion laufen lässt (syntactic sugar für for-loops)
sapply(1:4, function(i) i^2 +5)
sapply(1:4 , . %>% raise_to_power(2) %>% add(5) ) # dassselbe
```



## Assignment Rules

1. Get the assignment rules as string
2. Apply the assignment rules onto themselves with str_replace. This is for assigments that convert parameters into other parameters
```{r Asssignment Rules}
# get rules
nrules <- Model_getNumRules(m)
lrules <- Model_getListOfRules(m)
rules <- structure(sapply(0:(nrules-1), . %>% ListOfRules_get(lrules,.) %>% Rule_getFormula), 
                   names = sapply(0:(nrules-1), . %>% ListOfRules_get(lrules,.) %>% Rule_getId))
rulenames <- names(rules)

# "Cure" rules: Since I do a parameter trafo for the units, I don't want to have any unit conversions via some rules
# A "bad" rule would be eg "QC = CO*3600/100", since I take care of the Units later. Therefore, the rule should be only "QC = CO" 
rules <- rules %>% str_replace_all(c("1000" = "1", "3600" = "1", "\\b60\\b" = 1)) %>% set_names(rulenames)


# Apply the rules onto themselves to insert parameter transformations
# Final goal is to have a named vector where 
  # names are the "inner" parameters that are used within the model
  # values are functions of "outer" parameters that are fed into the model

# apply rules 1st time
rules <- paste0("(", rules, ")") %>% set_names(paste0("\\b", rulenames, "\\b"))
rules <- str_replace_all(rules, rules) %>% set_names(rulenames)

# apply rules 2nd time
rules <- paste0("(", rules, ")") %>% set_names(paste0("\\b", rulenames, "\\b"))
rules <- str_replace_all(rules, rules) %>% set_names(rulenames)

# check if any of the rules are functions of other rules
indices <- rules %>% sapply(. %>% str_detect(paste0("\\b",rulenames, "\\b")) %>% any)
rules %>% extract(indices) %>% sapply(. %>% str_detect(paste0("\\b",rulenames, "\\b")) %>% extract(rulenames,.)) # check works, none of the 

# print(rules)

# getSymbols(rules) # These are the "outer" parameters
```

## Reactions

```{r Reactions}
# get reactions
nreactions <- Model_getNumReactions(m)
lreactions <- Model_getListOfReactions(m)
reactions <- lapply(0:(nreactions-1), function(i) {
  
  reaction <-  ListOfReactions_get(lreactions,i)

  nreactants <- reaction %>% Reaction_getNumReactants()
  if (nreactants > 0) {
    lreactants <- reaction %>% Reaction_getListOfReactants()
    myreactant_stoichiometries <- lapply(0:(nreactants-1), . %>% ListOfSpeciesReferences_get(lreactants,.) %>% SpeciesReference_getStoichiometry)
    myreactant_IDs <- lapply(0:(nreactants-1), . %>% ListOfSpeciesReferences_get(lreactants,.) %>% SimpleSpeciesReference_getSpecies)
    from = paste0(paste0("(", myreactant_stoichiometries, "*", myreactant_IDs, ")"), collapse = "+")
  } else {
    from = ""
  }

  nproducts <- reaction %>% Reaction_getNumProducts()
  if (nproducts > 0) {
    lproducts <- reaction %>% Reaction_getListOfProducts()
    myproduct_stoichiometries <- lapply(0:(nproducts-1), . %>% ListOfSpeciesReferences_get(lproducts,.) %>% SpeciesReference_getStoichiometry)
    myproduct_IDs <- lapply(0:(nproducts-1), . %>% ListOfSpeciesReferences_get(lproducts,.) %>% SimpleSpeciesReference_getSpecies)
    to = paste0(paste0("(", myproduct_stoichiometries, "*", myproduct_IDs, ")"), collapse = "+")
  } else {
    to = ""
  }

  # Apply rules to rate expressions
  myrules <- rules
  mynames <- names(myrules)
  absorption_indices <- str_detect(myrules, "Absorption") 
  absorption_rules <- myrules[absorption_indices] %>% structure(names = mynames[absorption_indices])
  myrules <- structure(myrules[!str_detect(myrules, "Absorption")], names = paste0("\\b", mynames[!str_detect(myrules, "Absorption")], "\\b"))

  rate <-  reaction %>% Reaction_getKineticLaw() %>% KineticLaw_getFormula() %>% str_replace_all(myrules)
  
  description <- reaction %>% Reaction_getId()

  # Incorporate the absorption:
  # For this I add another reaction which absorbs the oral dose, e.g. D_apap_sul
  if(description %>% str_detect("Absorption")) {
    from[2] <- names(absorption_rules)[absorption_rules %>% str_detect(paste0(description, "\\)*$"))]
    to[2] <- ""
    rate[2] <- rate
    description[2] <- description
  }
  # print(i)
  
  return(data.frame(from = from, to  = to, rate = rate, description = description, stringsAsFactors = F))
}) %>% do.call(rbind,.) # make one big data.frame out of it


# Build the dMod-object "eqnlist", which stores the reactions and stoichiometries
el <- eqnlist()
for(i in 1:nrow(reactions)) el <- addReaction(el, reactions$from[i], reactions$to[i], reactions$rate[i], reactions$description[i])


# Convert to "eqnvec", which is basically a named vector of the ODEs and the names denote the states
f <- el %>% as.eqnvec()

# This is the full ODE when every rule is applied
# print(f)
```

## Parameters
```{r}
# get the parameters from the definition
nsbml_parameters <- m %>% Model_getNumParameters()
lsbml_parameters <- m %>% Model_getListOfParameters()
sbml_parameters <- structure(sapply(0:(nsbml_parameters-1), . %>% ListOfParameters_get(lsbml_parameters,.) %>% Parameter_getValue), names = sapply(0:(nsbml_parameters-1), . %>% ListOfParameters_get(lsbml_parameters,.) %>% Parameter_getId))

# unit conversion
sbml_parameter_units <- structure(sapply(0:(nsbml_parameters-1), . %>% ListOfParameters_get(lsbml_parameters,.) %>% Parameter_getUnits), names = sapply(0:(nsbml_parameters-1), . %>% ListOfParameters_get(lsbml_parameters,.) %>% Parameter_getId))
# The factors to bring each parameter to the units seconds, grams, litres
multiplication_factors <- sapply(0:(nsbml_parameters-1), . %>% 
         ListOfParameters_get(lsbml_parameters,.) %>% 
         Parameter_getDerivedUnitDefinition %>%
         {myunitdef <- .
           nunits <- UnitDefinition_getNumUnits(myunitdef)
         lunits <- UnitDefinition_getListOfUnits(myunitdef)
         lapply(0:(nunits-1), . %>%
                  ListOfUnits_get(lunits,.) %>%
                  {(Unit_getMultiplier(.) * 10^(Unit_getScale(.)))^Unit_getExponent(.)}) %>% Reduce("*",.)
         } %>%
         {.}
       )
sbml_parameters <- sbml_parameters * multiplication_factors


# Initial assignments
niass <- m %>% Model_getNumInitialAssignments()
liass <- m %>% Model_getListOfInitialAssignments()
iass <- structure(sapply(0:(niass-1), . %>% ListOfInitialAssignments_get(liass,.) %>% print %>%  str_split("\n") %>% sapply( . %>% {.[str_detect(.,"<ci>")]}) %>% str_replace_all("^.*<ci> ", "") %>% str_replace_all(" </ci>.*$", "")), names = sapply(0:(niass-1), . %>% ListOfInitialAssignments_get(liass,.) %>% InitialAssignment_getId)) 

nspecies <- Model_getNumSpecies(m)
lspecies <- Model_getListOfSpecies(m)
species <- lapply(0:(nspecies-1), . %>% {ListOfSpecies_get(lspecies,.)} %>% Species_getId()) %>% do.call(c,.)

inits <- structure(sapply(0:(nspecies-1), . %>% ListOfSpecies_get(lspecies,.) %>% Species_getInitialAmount), names = species)
inits[names(iass)] <- sbml_parameters[iass]

# All parameters combined, more than actually needed, because many of them have been replaced due to Rules
all_pars <- c(sbml_parameters, inits) # all possible parameters

# To check if the unit conversion worked
data.frame(par = names(sbml_parameters), value = sbml_parameters, original_unit= sbml_parameter_units,  multiplication_factor = multiplication_factors, original_value = sbml_parameters/multiplication_factors, row.names = NULL) #%>% 
  # filter(par %in% c("MET2APAP_HLM_CL", "fumic_metc13", "MPPGL", "BW", "FVli"))  #%>% summarise(prod(multiplication_factor))
  # filter(par %in% c("CO", "QC"))
# rules[str_detect(rules, "MET2APAP")]
# rules[str_detect(rules, "CO")]

```

## C-Code
the odemodel() command takes a while because sensitivity equations are calculated for derivatives and then the whole system is compiled into c-code.
```{r}
# myodemodel <- odemodel(f, modelname = "methacetin") # this compiles the ode into a c-file. you can comment out this and the next line after it has been run once to save time.
# save(myodemodel, file = "methacetin.rda")

load("methacetin.rda")
```

## Prediction function
Make a prediction function from the odemodel.
x will be a function x(times, pars)
```{r}
x <- Xs(myodemodel) # make prediction function
loadDLL(x)

# get the only the parameters needed for x
pars <- all_pars[getParameters(x)]
```

## Example plot
This plot is supposed to be the first plot from chunk 3 of the html-file that you sent me via email.
```{r}
pars["Ave_metc13"] <- 0
pars["D_metc13"] <- 0.1 #100mg

mytimes = seq(0,8*3600, length.out = 400) #8 hours

# pred <- (g*x)(0:50, mypars, deriv = F, conditions = rownames(attr(data, "cond")))
prediction <- (x)(times = mytimes, pars = pars, deriv = F, conditions = "c1")

# Compute the volumes in litres for each state
volumes <- lapply(0:(nspecies-1), . %>% {ListOfSpecies_get(lspecies,.)} %>% Species_getCompartment()) %>% do.call(c,.) %>% set_names(species)
myrules <- rules %>% set_names(paste0("\\b", rulenames, "\\b"))
volumes <- str_replace_all(volumes, myrules) %>% set_names(species)
vol_fun <- funC0(volumes)
vol <- do.call(vol_fun, as.list(pars)) %>% t %>% {data.frame(volume=., name = rownames(.), stringsAsFactors = F)}

# Plot
plot_fun <- function(pred) pred %>% 
  wide2long() %>% 
  full_join(vol,by= "name") %>% 
  mutate(value = value * 1000, time = time/3600, concentration = value/volume) %>% # scale g to mg, s to h
  separate(col = name, into = c("compartment", "substance"), sep = "_", extra = "merge") %>% 
  filter(compartment %in% c("Ali", "Ave", "Alu")) %>% # plot only liver, venuous and lung (as in the html file)
  ggplot(aes(x= time, y = concentration)) +
  geom_line(aes(color = compartment)) + 
  facet_wrap(~substance, scales = "free") + 
  theme_dMod() + scale_color_dMod()

save(f, file = "~/Promotion/Projects/methacetin_fitting/R/f.rda")

plot_fun(prediction)

prediction_long <- (x)(times = mytimes*20,pars = pars, deriv = F, conditions = "c1")
plot_fun(prediction_long)

# Second plot from chunk 3
pars <- all_pars[getParameters(x)]
pars["Ave_metc13"] <- 0.1
pars["D_metc13"] <- 0 #100mg
# pars["Kplu_metc13"] <- 1
# pars["FVlu"] <- 7.6*10^(-6) * 10

prediction_second_plot <- (x)(times = mytimes,pars = pars, deriv = F, conditions = "c1")
plot_fun(prediction_second_plot)

```

# Modelling

Reduce the model complexity by inserting the fixed parameter values
```{r Reduce model}
free_parameters <- c("APAPGLU_HLM_CL",  # Vmax value
                     "APAPGLU_Km",  # Km value
                     "APAPSUL_HLM_CL",  # Vmax value
                     "APAPGLU_Km",  # Km value
                     "APAPCYS_HLM_CL",  # Vmax value
                     "APAPCYS_Km"  # Km value
                     )


fixed_parameters <- pars[!(names(pars)%in%c(free_parameters,names(f)[1]))] %>% names


myodemodel <- odemodel(f, modelname = "methacetin_reduced", fixed = fixed_parameters)

x <- Xs(myodemodel)

```

## Observation function
```{r observation function, results='hide'}
observables <- c(apap = "Ave_apap/(BW*FVve)", 
                 apap_glu = "Ave_apap_glu/(BW*FVve)", 
                 apap_sul = "Ave_apap_sul/(BW*FVve)", 
                 apap_cys = "Ave_apap_cys/(BW*FVve)"
                 )

g <- Y(observables, x, parameters = free_parameters)


```

```{r}
(g*x)(mytimes, pars) %>% set_names("condition1") %>% plotPrediction(name %in% names(observables))
```


# Data
Load the data and transform it
```{r data}
myfiles <- list.files("~/Promotion/Projects/methacetin_fitting/data/", full.names = T)


raw_data <- myfiles %>% lapply(. %>% read.table(header = T, sep = "\t", stringsAsFactors = F))


data <-
  raw_data %>% 
  lapply(. %>% 
           select(-contains("_mol")) %>% 
           gather("name_std", "std", ends_with("_sd")) %>% 
           mutate(name_std = str_replace(name_std, "_sd","")) %>% 
           gather("name_sigma", "sigma", ends_with("_se")) %>% 
           mutate(name_sigma = str_replace(name_sigma, "_se","")) %>% 
           {gather(.,"name", "value", one_of(.$name_std))} %>% 
           filter(name == name_std, name == name_sigma) %>% 
           # select(name,time,value,sigma) %>% 
           {.}) %>% 
    do.call(dMod::combine,.) %>% 
    mutate(D_apap = "D_apap", Ave_apap = "Ave_apap" ) %>% 
    {.$D_apap[.$study=="Chan1997"] <- 1400 / 1000
    .$Ave_apap[.$study=="Chan1997"] <- 0
    .$D_apap[.$study=="Chiew2010"] <- 5600 / 1000
    .$Ave_apap[.$study=="Chiew2010"] <- 0
    .$D_apap[.$study=="Critchley2005"] <- 1400 /1000
    .$Ave_apap[.$study=="Critchley2005"] <- 0
    .$D_apap[.$study=="Rawlins1977"] <- .$dose[.$study=="Rawlins1977"] * (.$route[.$study=="Rawlins1977"]%in%"oral") / 1000
    .$Ave_apap[.$study=="Rawlins1977"] <- .$dose[.$study=="Rawlins1977"] * (.$route[.$study=="Rawlins1977"]%in%"iv") / 1000
    .
    } %>% 
  mutate(time = time * 3600, value = value/1000, sigma = sigma/1000) %>% 
  select(-group, -health_status, - name_std, - name_sigma, -std, -ethnicity, -route, -dose, -n, -substance) %>%
  filter(!is.na(sigma)) %>% 
  as.datalist() %>% 
           {.}

  
  

plot(data)
```


Parameter transformations to define the conditions
```{r}
conditions <- data %>% attr("condition.grid")

p_list <- lapply(1:nrow(conditions), function(i) {
  trafo <- as.character(pars) %>% set_names(names(pars))
  cond <- unlist(conditions[i,])[2:3]
  
  trafo[names(cond)] <- cond
  trafo[free_parameters] <- paste0("exp(log", free_parameters, ")")
  
  p <- P(trafo, condition=rownames(conditions[i,]))
  return(p)
})
p <- NULL
for(i in 1:length(p_list)) { p <<- p + p_list[[i]]}

pouter <- log(pars[free_parameters]) %>% set_names(paste0("log",names(.)))


mypred <- (g*x*p)(seq(0, 48*3600, length.out = 200), pouter)
plotCombined(mypred, data, name%in% names(observables))
```
## Fitting

```{r Objective function}
obj <- normL2(data, (g*x*p))


# myfit <- mstrust(objfun = obj, center = pouter, studyname = "methacetin", cores = 3)
# save(myfit, file = "fit.rda")
load("fit.rda")

fitted_pars <- myfit %>% as.parframe() %>% as.parvec()
```

```{r}
mypred <- (g*x*p)(seq(0, 48*3600, length.out = 200), fitted_pars)

liver <- names(f)[str_detect(names(f), "li")]
medication <- c(names(f)[str_detect(names(f), "D_apap$")], "Ave_apap")


plotCombined(mypred, data, name %in% c(names(observables), liver, medication))
```

Look at the pars
```{r}
exp(fitted_pars) %>% sort()
```


# Profiles
```{r}
# profiles <- profile(obj = obj, pars = fitted_pars, whichPar = names(fitted_pars), cores = 3)
```

```{r}
# plotProfile(profiles)

```



# Look at some reactions
```{r}
reactions %>% filter(str_detect(rate, "APAPSUL"))
```


```{r}
mypred <- (g*x*p)(seq(0, 48*3600, length.out = 200), fitted_pars)

liver <- names(f)[str_detect(names(f), "li")]
medication <- c(names(f)[str_detect(names(f), "D_apap$")], "Ave_apap")


plotCombined(mypred, data, name %in% c(names(observables), liver, medication))
```
# Free some more parameters

```{r}
data <-
  raw_data %>% 
  lapply(. %>% 
           select(-contains("_mol")) %>% 
           gather("name_std", "std", ends_with("_sd")) %>% 
           mutate(name_std = str_replace(name_std, "_sd","")) %>% 
           gather("name_sigma", "sigma", ends_with("_se")) %>% 
           mutate(name_sigma = str_replace(name_sigma, "_se","")) %>% 
           {gather(.,"name", "value", one_of(.$name_std))} %>% 
           filter(name == name_std, name == name_sigma) %>% 
           {.}) %>% 
  do.call(dMod::combine,.) %>% 
  mutate(D_apap = "D_apap", Ave_apap = "Ave_apap" ) %>% 
  {.$D_apap[.$study=="Chan1997"] <- 1400 / 1000
  .$Ave_apap[.$study=="Chan1997"] <- 0
  .$D_apap[.$study=="Chiew2010"] <- 5600 / 1000
  .$Ave_apap[.$study=="Chiew2010"] <- 0
  .$D_apap[.$study=="Critchley2005"] <- 1400 /1000
  .$Ave_apap[.$study=="Critchley2005"] <- 0
  .$D_apap[.$study=="Rawlins1977"] <- .$dose[.$study=="Rawlins1977"] * (.$route[.$study=="Rawlins1977"]%in%"oral") / 1000
  .$Ave_apap[.$study=="Rawlins1977"] <- .$dose[.$study=="Rawlins1977"] * (.$route[.$study=="Rawlins1977"]%in%"iv") / 1000
  .
  } %>% 
  mutate(time = time * 3600, value = value/1000, sigma = sigma/1000) %>% 
  select(-group, -health_status, - name_std, - name_sigma, -std, -ethnicity, -route, -dose, -substance) %>%
  # filter(!is.na(sigma)) %>% 
  # as.datalist() %>%
  {.}
```


```{r}
load("methacetin.rda")

x <- Xs(myodemodel) # make prediction function
loadDLL(x)

# get the only the parameters needed for x
pars <- all_pars[getParameters(x)]

free_parameters1 <- c("APAPGLU_HLM_CL",  # Vmax value
                     "APAPGLU_Km",  # Km value
                     "APAPSUL_HLM_CL",  # Vmax value
                     "APAPGLU_Km",  # Km value
                     "APAPCYS_HLM_CL",  # Vmax value
                     "APAPCYS_Km",  # Km value
                     
                     "Ka_apap_sul", "F_apap_sul", 
                     "Kpre_apap", "Kpki_apap", "Kpli_apap", 
                     "Kpre_apap_cys", "Kpki_apap_cys", "Kpli_apap_cys",
                     "Kpre_apap_glu", "Kpki_apap_glu", "Kpli_apap_glu",
                     "Kpre_apap_sul", "Kpre_apap_glu", "Kpli_apap_glu",
                     "Kpre_co2c13", "Kpre_co2c13", "Kpli_co2c13",
                     "Kpre_metc13", "Kpre_metc13", "Kpli_metc13"
                     )

fixed_parameters1 <- pars[!(names(pars)%in%c(free_parameters1,names(f)[1]))] %>% names

mydatalist <- data  %>% filter(!is.na(sigma)) %>% as.datalist() 

conditions <- mydatalist %>% attr("condition.grid")

p_list <- lapply(1:nrow(conditions), function(i) {
  trafo <- as.character(pars) %>% set_names(names(pars))
  cond <- unlist(conditions[i,])[2:3]
  
  trafo[names(cond)] <- cond
  trafo[free_parameters1] <- paste0("exp(log", free_parameters1, ")")
  
  p <- P(trafo, condition=rownames(conditions[i,]))
  return(p)
})
p <- NULL
for(i in 1:length(p_list)) { p <<- p + p_list[[i]]}

pouter <- log(pars[free_parameters1]) %>% set_names(paste0("log",names(.)))


# mypred <- (g*x*p)(seq(0, 48*3600, length.out = 200), pouter)
# plotCombined(mypred, mydatalist, name%in% names(observables))

obj <- normL2(mydatalist, (g*x*p))

job1 <- runbg({myfit <- mstrust(objfun = obj, center = pouter, studyname = "methacetin", cores = 20, fits = 100); myfit}, machine = "knecht3", filename = "job1")

```


```{r}
load("methacetin.rda")

x <- Xs(myodemodel) # make prediction function
loadDLL(x)

# get the only the parameters needed for x
pars <- all_pars[getParameters(x)]

free_parameters2 <- c("APAPGLU_HLM_CL",  # Vmax value
                     "APAPGLU_Km",  # Km value
                     "APAPSUL_HLM_CL",  # Vmax value
                     "APAPGLU_Km",  # Km value
                     "APAPCYS_HLM_CL",  # Vmax value
                     "APAPCYS_Km",  # Km value
                     
                     "Ka_apap_sul", "F_apap_sul"    #, 
                     # "Kpre_apap", "Kpki_apap", "Kpli_apap", 
                     # "Kpre_apap_cys", "Kpki_apap_cys", "Kpli_apap_cys",
                     # "Kpre_apap_glu", "Kpki_apap_glu", "Kpli_apap_glu",
                     # "Kpre_apap_sul", "Kpre_apap_glu", "Kpli_apap_glu",
                     # "Kpre_co2c13", "Kpre_co2c13", "Kpli_co2c13",
                     # "Kpre_metc13", "Kpre_metc13", "Kpli_metc13"
                     )

fixed_parameters2 <- pars[!(names(pars)%in%c(free_parameters2,names(f)[1]))] %>% names

mydatalist <- data  %>% filter(!is.na(sigma)) %>% as.datalist() 

conditions <- mydatalist %>% attr("condition.grid")

p_list <- lapply(1:nrow(conditions), function(i) {
  trafo <- as.character(pars) %>% set_names(names(pars))
  cond <- unlist(conditions[i,])[2:3]
  
  trafo[names(cond)] <- cond
  trafo[free_parameters2] <- paste0("exp(log", free_parameters2, ")")
  
  p <- P(trafo, condition=rownames(conditions[i,]))
  return(p)
})
p <- NULL
for(i in 1:length(p_list)) { p <<- p + p_list[[i]]}

pouter <- log(pars[free_parameters2]) %>% set_names(paste0("log",names(.)))


# mypred <- (g*x*p)(seq(0, 48*3600, length.out = 200), pouter)
# plotCombined(mypred, mydatalist, name%in% names(observables))

obj <- normL2(mydatalist, (g*x*p))

job2 <- runbg({myfit <- mstrust(objfun = obj, center = pouter, studyname = "methacetin", cores = 12, fits = 100); myfit}, machine = "knecht4", filename = "job2")


```



```{r}
load("methacetin.rda")

x <- Xs(myodemodel) # make prediction function
loadDLL(x)

# get the only the parameters needed for x
pars <- all_pars[getParameters(x)]

free_parameters3 <- c("APAPGLU_HLM_CL",  # Vmax value
                     "APAPGLU_Km",  # Km value
                     "APAPSUL_HLM_CL",  # Vmax value
                     "APAPGLU_Km",  # Km value
                     "APAPCYS_HLM_CL",  # Vmax value
                     "APAPCYS_Km",  # Km value
                     
                     "Ka_apap_sul", "F_apap_sul"    , 
                     "Kpre_apap", "Kpki_apap", "Kpli_apap",
                     "Kpre_apap_cys", "Kpki_apap_cys", "Kpli_apap_cys",
                     "Kpre_apap_glu", "Kpki_apap_glu", "Kpli_apap_glu",
                     "Kpre_apap_sul", "Kpre_apap_glu", "Kpli_apap_glu"#,
                     # "Kpre_co2c13", "Kpre_co2c13", "Kpli_co2c13",
                     # "Kpre_metc13", "Kpre_metc13", "Kpli_metc13"
                     )

fixed_parameters3 <- pars[!(names(pars)%in%c(free_parameters3,names(f)[1]))] %>% names

mydatalist <- data  %>% filter(!is.na(sigma)) %>% as.datalist() 

conditions <- mydatalist %>% attr("condition.grid")

p_list <- lapply(1:nrow(conditions), function(i) {
  trafo <- as.character(pars) %>% set_names(names(pars))
  cond <- unlist(conditions[i,])[2:3]
  
  trafo[names(cond)] <- cond
  trafo[free_parameters3] <- paste0("exp(log", free_parameters3, ")")
  
  p <- P(trafo, condition=rownames(conditions[i,]))
  return(p)
})
p <- NULL
for(i in 1:length(p_list)) { p <<- p + p_list[[i]]}

pouter <- log(pars[free_parameters3]) %>% set_names(paste0("log",names(.)))


# mypred <- (g*x*p)(seq(0, 48*3600, length.out = 200), pouter)
# plotCombined(mypred, mydatalist, name%in% names(observables))

obj <- normL2(mydatalist, (g*x*p))

job3 <- runbg({myfit <- mstrust(objfun = obj, center = pouter, studyname = "methacetin", cores = 15, fits = 100); myfit}, machine = "knecht1", filename = "job3")

```

```{r}
# save(list = c("job1", "job2", "job3"), file = "fit_jobs.rda")
```









# Data revisited
Some sigmas of the data are NA, try to recover an estimate for the sigmas from the other sigmas
```{r}
myfiles <- list.files("~/Promotion/Projects/methacetin_fitting/data/", full.names = T)

raw_data <- myfiles %>% lapply(. %>% read.table(header = T, sep = "\t", stringsAsFactors = F))

data <-
  raw_data %>% 
  lapply(. %>% 
           select(-contains("_mol")) %>% 
           gather("name_std", "std", ends_with("_sd")) %>% 
           mutate(name_std = str_replace(name_std, "_sd","")) %>% 
           gather("name_sigma", "sigma", ends_with("_se")) %>% 
           mutate(name_sigma = str_replace(name_sigma, "_se","")) %>% 
           {gather(.,"name", "value", one_of(.$name_std))} %>% 
           filter(name == name_std, name == name_sigma) %>% 
           {.}) %>% 
  do.call(dMod::combine,.) %>% 
  mutate(D_apap = "D_apap", Ave_apap = "Ave_apap" ) %>% 
  {.$D_apap[.$study=="Chan1997"] <- 1400 / 1000
  .$Ave_apap[.$study=="Chan1997"] <- 0
  .$D_apap[.$study=="Chiew2010"] <- 5600 / 1000
  .$Ave_apap[.$study=="Chiew2010"] <- 0
  .$D_apap[.$study=="Critchley2005"] <- 1400 /1000
  .$Ave_apap[.$study=="Critchley2005"] <- 0
  .$D_apap[.$study=="Rawlins1977"] <- .$dose[.$study=="Rawlins1977"] * (.$route[.$study=="Rawlins1977"]%in%"oral") / 1000
  .$Ave_apap[.$study=="Rawlins1977"] <- .$dose[.$study=="Rawlins1977"] * (.$route[.$study=="Rawlins1977"]%in%"iv") / 1000
  .
  } %>% 
  mutate(time = time * 3600, value = value/1000, sigma = sigma/1000) %>% 
  select(-group, -health_status, - name_std, - name_sigma, -std, -ethnicity, -route, -dose, -substance) %>%
  # filter(!is.na(sigma)) %>% 
  # as.datalist() %>%
  {.}



mydatalist <- data %>% select(-n) %>% as.datalist()

plotData(mydatalist[names(mydatalist) %>% str_detect("Chan")])

```

Take out some outliers for the fitting. Those are:
study, name, time, reason
1. Chan1997, apap_cys, 5400,   don't know what went wrong with this one, but it just doesn't fit reasonably in the time course
3. Chan1997, apap,     18000,  The sigma is a few orders of magnitude lower. Mirjam said it might be that in this point less people were measured (eg 2) and they had nearly the same value. Then of course, sigma would be very smal
```{r}
# data <- data %>% 
#   filter(!((study %>% str_detect("Chan")) & (name %in% "apap_cys") & time == 5400)) %>% 
#   filter(!((study %>% str_detect("Chan")) & (name %in% "apap") & time == 18000)) %>% 
#   {.}

 data %>% select(-n) %>% filter(study %>% str_detect("Chiew"))%>% as.datalist() %>% plotData()
```

```{r}
data_with_errors <- data %>% 
  filter(!((study %>% str_detect("Chan")) & (name %in% "apap_cys") & time == 5400)) %>% 
  filter(!((study %>% str_detect("Chan")) & (name %in% "apap") & time == 18000)) %>% 
  fitErrorModel(factors = c("study", "D_apap", "Ave_apap", "name"), blather = T)

data_with_errors %>% select(study, name, D_apap, s0, srel) %>% unique()
```

What's the problem with the Chiew-dataset? The error model doesn't work out, somehow
```{r}
data_with_errors %>% 
  filter(study %>% str_detect("Chiew"), name %in% "apap") %>% 
ggplot(aes(x=value)) +
            geom_point(aes(y=sigmaLS^2*(n), color = log(time))) +
            geom_line(aes(y=sigma^2*n)) +
            geom_ribbon(aes(ymin=cbLower95, ymax=cbUpper95), alpha=.3) +
            geom_ribbon(aes(ymin=cbLower68, ymax=cbUpper68), alpha=.3) +
            ylab("variance") +
            facet_wrap(~condidnt, scales = "free") +
            scale_y_log10() +
            theme_dMod() + 
            scale_color_continuous( low = "#98f5ff", high = "#4c4cdb")

```

```{r}
myplot <- data_with_errors %>% 
  rename(sigma_fitted = sigma) %>% 
  left_join(data) %>% 
  gather("which_sig", "sigma", sigma, sigma_fitted) %>% 
  mutate(condition = paste0(study, D_apap)) %>% 
  ggplot(aes(x = time,y = log10(sigma))) +
  geom_line(aes(color = condition, linetype = which_sig)) +
  # geom_point(aes(color = condition, shape = which_sig))+
  facet_wrap("name", scales = "free") 
  
myplot %>% plotly::ggplotly()

```












































