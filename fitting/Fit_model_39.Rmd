---
title: "Fitting model 39"
output: 
  html_document:
    toc: TRUE
---


Load all important libraries
```{r, message=FALSE, warning=FALSE, eval=TRUE, echo=FALSE}
knitr::opts_chunk$set(eval = FALSE)
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(fig.height = 10)
knitr::opts_chunk$set(fig.width = 15)
library(dMod)
library(stringr) # Um bequem mit strings zu arbeiten
library(tidyverse) # Viele Funktionen, u.a. für data.frames und ggplot2 für schöne plots
library(magrittr) # der Pipe-operator %>%: z.B: x =" a; y="f(x); z="g(y); wird zu z=" a %>% f %>% g
library(conveniencefunctions)

merge_col2_into_col1 <- function(.data, col1, col2) {
  
  c1 <- enquo(col1)
  c2 <- enquo(col2)
  
  c1name <- quo_name(c1)
  c2name <- quo_name(c1)
  
  UQ <- rlang::UQ

  mutate(.data, UQ(c1name) := replace(UQ(c1), is.na(UQ(c1)), UQ(c2)[is.na(UQ(c1))])) %>% 
    select(-UQ(c2))
}

# load("2018_03_09_17_17_workspace.rda")
# for(i in lsdMod(classlist = "prdfn")) {loadDLL(i)}
```


# Read model
```{r}
source("../model/limax_pkpd_39.R")
```

```{r}
pars_raw <- c(x0, p) 
pars_in_dxdtdmod <- c(getSymbols(dxdt_dmod), names(dxdt_dmod))
```

# Odemodels and predicition function

## Apap
```{r odemodel_apap}
free_pars_apap <- c("Ka_apap", "APAPD_HLM_CL", "APAPD_Km_apap")
odemodel_apap <- odemodel(dxdt_dmod, modelname = "odemodel_apap", fixed = setdiff(pars_in_dxdtdmod, c(free_pars_apap, "Aar_apap"))) # Aar_apap is not there to be optimized, but a variable which is a state is needed because of a bug in odemodel.

x_apap <- Xs(odemodel_apap)
```


### Apap_doses
```{r odemodel_apap_doses}
free_pars_apap_doses <- c(free_pars_apap, "PODOSE_apap", "IVDOSE_apap")
odemodel_apap_doses <- odemodel(dxdt_dmod, modelname = "odemodel_apap_doses", fixed = setdiff(pars_in_dxdtdmod, c(free_pars_apap_doses, "Aar_apap"))) # Aar_apap is not there to be optimized, but a variable which is a state is needed because of a bug in odemodel.

x_apap_doses <- Xs(odemodel_apap_doses)
```

## Bicarbonate

```{r odemodel_bic}
free_pars_bic <- c("Ka_co2c13", "KLU_EXCO2", "CO2FIX_HLM_CL", "KBO_FIXCO2", "KBO_RELCO2", "KBO_MAXCO2")
odemodel_bic <- odemodel(dxdt_dmod, modelname = "odemodel_bic", fixed = setdiff(pars_in_dxdtdmod, c(free_pars_bic, "Aar_apap"))) # Aar_apap is not there to be optimized, but a variable which is a state is needed because of a bug in odemodel.

x_bic <- Xs(odemodel_bic)
```

## Metc13

```{r odemodel_met}
free_pars_met <- c("Ka_metc13", "CYP1A2MET_CL", "CYP1A2MET_Km_met")
odemodel_met <- odemodel(dxdt_dmod, modelname = "odemodel_met", fixed = setdiff(pars_in_dxdtdmod, c(free_pars_met, "Aar_apap"))) # Aar_apap is not there to be optimized, but a variable which is a state is needed because of a bug in odemodel.

x_met <- Xs(odemodel_met)
```

## Combined

```{r odemodel_apap_bic_met}
free_pars_apap_bic_met <- c(free_pars_apap_doses, free_pars_bic, free_pars_met) %>% unique
odemodel_apap_bic_met <- odemodel(dxdt_dmod, modelname = "odemodel_apap_bic_met", fixed = setdiff(pars_in_dxdtdmod, c(free_pars_apap_bic_met, "Aar_apap"))) # Aar_apap is not there to be optimized, but a variable which is a state is needed because of a bug in odemodel.

x_apap_bic_met <- Xs(odemodel_apap_bic_met)
```

```{r}

```



# Observation functions

## Apap, Apap_dose

```{r g_apap}
observables_apap <- y_dmod[c("Mve_apap", "DOB")] %>% set_names(c("apap", "dob_apap"))
g_apap <- Y(g = observables_apap, f = x_apap)
```

## Bicarbonate

```{r g_bic}
recovery_bic <- paste(y_dmod["Exhalation_co2c13"], "/ 60 * Mr_co2c13 / Ri_co2c13 * 100")
observables_bic <- c(recovery_bic, y_dmod[c("DOB", "P_CO2Fc13")])
names(observables_bic) <- c("recovery_bic", "dob_bic", "co2_ratio_bic")

observables_bic["co2_ratio_bic"] <- paste0(observables_bic["co2_ratio_bic"], " + offset_bic")

g_bic <- Y(observables_bic, x_bic)
```

## Metc13

```{r g_met}
recovery_met <- paste(y_dmod["Exhalation_co2c13"], "/ init_PODOSE_metc13 * Mr_metc13 * 100" )
cum_met <- paste( "Abreath_co2c13/ init_PODOSE_metc13 * Mr_metc13 * 100")
observables_met <- c(recovery_met, cum_met) %>% set_names(c("recovery_met", "cum_met"))

g_met <- Y(observables_met, x_met)
```

## Combined

```{r g_apap_bic_met}
observables_apap_bic_met <- c(observables_apap, observables_bic, observables_met)
g <- Y(observables_apap_bic_met, x_apap_bic_met)
```



# Data 
Read data, insert the default values for the parameters supplied in the data sheet. 
```{r, message=FALSE}
data <- read_csv("data.csv") %>% as.data.frame
supplied_pars <- names(pars_raw)[(names(pars_raw) %in% names(data))]
data[supplied_pars][is.na(data[supplied_pars])] <- 0
```


# Parameter trafos
## Apap
```{r p_apap}
data_apap <- data %>% 
  filter((IVDOSE_apap!=0)|(PODOSE_apap!=0))
  
outer_pars_apap <- sort(c(supplied_pars, free_pars_apap))

trafo_apap <-
  pars_raw %>% 
  sort_by_name() %>% 
  replace((names(.) %in% outer_pars_apap), outer_pars_apap) %>% 
  
  branch(data_apap %>% as.datalist() %>% covariates()) %>% 
  
  minsert(supplied_pars) %>% 
  
  insert("x~exp(X)", x = free_pars_apap, X = toupper(free_pars_apap)) # backtrafo to linear pars from log-pars

p_apap <- P(trafo_apap)

pars_apap <- log(pars_raw[free_pars_apap]) %>% set_names(toupper(free_pars_apap))
```

### Test plot
```{r plot_apap, eval=TRUE}
# loadDLL(x_apap)
times <- seq(0,24, 0.1)
plotCombined((g_apap*x_apap*p_apap)(times, pars_apap, deriv = F), data = data_apap %>% as.datalist(), name %in% names(observables_apap))
```

## Apap, study-specific aborption rates
```{r, warning=FALSE}
outer_pars_apap <- sort(c(supplied_pars, free_pars_apap))

trafo_apap_free_ka <-
  pars_raw %>% 
  sort_by_name() %>% 
  replace((names(.) %in% outer_pars_apap), outer_pars_apap) %>% 
  
  branch(data_apap %>% as.datalist() %>% covariates()) %>% 
  
  minsert(supplied_pars) %>% 
  
  insert("x~x_study_group", x = "Ka_apap", study = study, group = group) %>% 
  
  insert("x~exp(X)", 
         x = getSymbols(mytrafo[[i]]), 
         X = toupper(getSymbols(mytrafo[[i]])))  # hacking insert()...



p_apap_free_ka <- P(trafo_apap_free_ka)

pars_apap_free_ka <- getParameters(p_apap_free_ka) %>% are_names_of(0)
```


## Bicarbonate

Some studies don't have sigmas. Estimate the errors for them while fitting. For this, we need to define an error model.
1. Split the data into studies a) with errors "_bic" and b) without errors "_bic_sigma_NA"
2. Define the error model (technically, this will also be an observation function: It "observes" the outputs of the model, e.g. "recovery", and calculates another variable from it, the error)
3. For both sets of data, "_bic", and "bic_sigma_NA", we now need condition specific parameters. Additionally, in "_bic_sigma_NA", we need to supply the parameters of our error model.

### Error model
TODO: FIX ERROR MODEL (Parameter)

```{r e_bic}
data_bic <- data %>% 
  filter((IVDOSE_co2c13!=0)|(PODOSE_co2c13!=0)|Ri_co2c13!=0)

studies_with_sigma_na <- data_bic %>% filter(is.na(sigma)) %>% .[["study"]] %>% unique
data_bic_sigma_NA <- data_bic %>% filter(study %in% studies_with_sigma_na)
data_bic <- data_bic %>% filter(! study %in% studies_with_sigma_na)

errors_bic_sigma_NA <- paste0("sqrt(s0_", names(observables_bic), "^2 + srel_", names(observables_bic), "^2 * ", names(observables_bic), "^2 )") %>% set_names(names(observables_bic))

e_bic_sigma_NA <- Y(g = errors_bic_sigma_NA, f= (g_bic))
```

### Parameter trafo
```{r p_bic}
outer_pars_bic <- sort(c(supplied_pars, free_pars_bic))

trafo_bic<-
  c(pars_raw) %>% 
  sort_by_name() %>% 
  replace((names(.) %in% outer_pars_bic), outer_pars_bic) %>% 
  
  branch(data_bic %>% as.datalist() %>% covariates()) %>% # The table of covariates includes dosepar and dose, which are used in the next line
  
  minsert(supplied_pars) %>% 

  insert("x~exp(X)", x = getSymbols(mytrafo[[i]]), X = toupper(getSymbols(mytrafo[[i]]))) %>% 
  
  define("x~x", x = "offset_bic")

p_bic <- P(trafo_bic)

pars_bic <- getParameters(p_bic) %>% are_names_of(0)
```

```{r p_bic_sigma_NA}
pars_errors_bic_sigma_NA <- getSymbols(errors_bic_sigma_NA) %>% str_subset("^s") %>% are_names_of(1)

outer_pars_bic <- sort(c(supplied_pars, free_pars_bic, names(pars_errors_bic_sigma_NA)))

trafo_bic_sigma_NA <-
  c(pars_raw, pars_errors_bic_sigma_NA) %>% 
  sort_by_name() %>% 
  replace((names(.) %in% outer_pars_bic), outer_pars_bic) %>% 
  
  branch(data_bic_sigma_NA %>% as.datalist() %>% covariates()) %>% # The table of covariates includes dosepar and dose, which are used in the next line
  
  minsert(supplied_pars) %>% 
  
  insert("s~s_study", s = names(pars_errors_bic_sigma_NA), study = study) %>% 
  
  insert("x~exp(X)", x = getSymbols(mytrafo[[i]]), X = toupper(getSymbols(mytrafo[[i]]))) %>% 
  
  insert("x~0", x = c("S0_CO2_RATIO_BIC_BARSTOW1990", "S0_RECOVERY_BIC_BARSTOW1990", 
"SREL_CO2_RATIO_BIC_BARSTOW1990", "SREL_RECOVERY_BIC_BARSTOW1990", 
"S0_DOB_BIC_MEINEKE1993", "S0_RECOVERY_BIC_MEINEKE1993", "SREL_DOB_BIC_MEINEKE1993", 
"SREL_RECOVERY_BIC_MEINEKE1993")) %>% 
  
  define("x~x", x = "offset_bic")

p_bic_sigma_NA <- P(trafo_bic_sigma_NA)

pars_bic_sigma_NA <- getParameters(p_bic_sigma_NA) %>% are_names_of(0)

# p_bic_sigma_NA(pars_bic_sigma_NA)
```

### Example plot
```{r}
loadDLL(x_bic)
(g_bic*x_bic*p_bic_sigma_NA)(times*10, pars_bic_sigma_NA, deriv = F) %>%  plotPrediction(name %in% names(observables_bic))
(g_bic*x_bic*p_bic)(times*10, pars_bic, deriv = F) %>%  
  # lapply(. %>% as.tibble)
  plotPrediction(name %in% names(observables_bic))

dosepars_bic
data_bic %>% 
  # filter(str_detect(name, "rec"))
  filter(study %>% str_detect("Lei"))
observables_bic
```


## Metc13

The same game for the data sets without sigmas applies here. Read the description for Bic.

### Error model
```{r e_met}
data_met <- data %>% filter((PODOSE_metc13!=0))

studies_with_sigma_na <- data_met %>% filter(is.na(sigma)) %>% .[["study"]] %>% unique
data_met_sigma_NA <- data_met %>% filter(study %in% studies_with_sigma_na)
data_met <- data_met %>% filter(! study %in% studies_with_sigma_na)

errors_met_sigma_NA <- paste0("sqrt(s0_", names(observables_met), "^2 + srel_", names(observables_met), "^2 * ", names(observables_met), "^2)") %>% set_names(names(observables_met))

e_met_sigma_NA <- Y(g = errors_met_sigma_NA, f= (g_met))
```

### Parameter trafo
```{r p_met}
outer_pars_met <- sort(c(supplied_pars, free_pars_met))

trafo_met<-
  c(pars_raw) %>% 
  sort_by_name() %>% 
  replace((names(.) %in% outer_pars_met), outer_pars_met) %>% 
  
  branch(data_met %>% as.datalist() %>% covariates()) %>%  # The table of covariates includes dosepar and dose, which are used in the next line
  
  minsert(supplied_pars) %>% 

  define("init_PODOSE_metc13~podose", podose = mytrafo[[i]]["PODOSE_metc13"]) %>% # For the observables, I need the initial dose as a fixed parameter which doesn't change. Because the PODOSE_metc13 is also a state, I need to duplicate this parameters
    
  insert("x~exp(X)", x = getSymbols(mytrafo[[i]]), X = toupper(getSymbols(mytrafo[[i]]))) 

p_met <- P(trafo_met)

pars_met <- getParameters(p_met) %>% are_names_of(0)
```


```{r p_met_sigma_NA}
pars_errors_met_sigma_NA <- getSymbols(errors_met_sigma_NA) %>% str_subset("^s") %>%  are_names_of(1)

outer_pars_met <- sort(c(supplied_pars, free_pars_met, names(pars_errors_met_sigma_NA)))

trafo_met_sigma_NA <-
  c(pars_raw, pars_errors_met_sigma_NA) %>% 
  sort_by_name() %>% 
  replace((names(.) %in% outer_pars_met), outer_pars_met) %>% 
  
  branch(data_met_sigma_NA %>% as.datalist() %>% covariates()) %>% # The table of covariates includes dosepar and dose, which are used in the next line
  
  minsert(supplied_pars) %>% 
  
  define("init_PODOSE_metc13~podose", podose = mytrafo[[i]]["PODOSE_metc13"]) %>% # For the observables, I need the initial dose as a fixed parameter which doesn't change. Because the PODOSE_metc13 is also a state, I need to duplicate this parameters
  
  insert("s~s_study", s = names(pars_errors_met_sigma_NA), study = study) %>% 
  
  insert("x~exp(X)", x = getSymbols(mytrafo[[i]]), X = toupper(getSymbols(mytrafo[[i]]))) %>% 
  insert("x~0", x = c("S0_CUM_MET_KRUMBIEGEL1985", "SREL_CUM_MET_KRUMBIEGEL1985"))
  


p_met_sigma_NA <- P(trafo_met_sigma_NA)

pars_met_sigma_NA <- getParameters(p_met_sigma_NA) %>% are_names_of(0)
```

### Example plot
```{r}
loadDLL(x_met)
(g_met*x_met*p_met_sigma_NA)(times*100, pars_met_sigma_NA, deriv = F) %>% plotPrediction(name %in% names(observables_met))
```



```{r initialize dMod.frame }
dMod.frame <- tibble(hypothesis = c("apap", "apap_free_ka", "bic", "met"),
                     x = list(x_apap, x_apap, x_bic, x_met)) %>% 
  add_column( g = list(g_apap, g_apap, g_bic, g_met)) %>% 
  add_column(p = list(p_apap, p_apap_free_ka, p_bic, p_met),
             data = list(data_apap, data_apap, data_bic, data_met),
             p_sig = list(NULL, NULL, p_bic_sigma_NA, p_met_sigma_NA),
             e = list(NULL, NULL, e_bic_sigma_NA, e_met_sigma_NA),
             data_sig = list(NULL, NULL, data_bic_sigma_NA, data_met_sigma_NA)
  )
```



# Fit

## Objective functions

Now, we define all necessary objective functions, which are handed to the optimizers.

```{r read pars from previous fits}
fitted_pars <- readRDS("fitted_pars.rds")
fitted_pars[[3]] <- c(fitted_pars[[3]], "offset_bic" = -0.01)
fitted_pars[[4]]["S0_RECOVERY_MET_KRUMBIEGEL1985"] <- -1
```



```{r dMod.frame objfuns}
dMod.frame <- dMod.frame %>% 
  mutate(data = map(data, as.datalist),
         data_sig = map(data_sig, as.datalist)) %>% 
  mutate(prd = map(seq_along(x), function(i) cfn(g[[i]], cfn(x[[i]],p[[i]]))),
         prd_sig = map(seq_along(x), function(i) cfn(g[[i]], cfn(x[[i]],p_sig[[i]])))) %>% 
  mutate(obj_0 = map(seq_along(x), function(i) normL2(data[[i]], prd[[i]])),
         obj_sig = map(seq_along(x), function(i) cf_normL2(data = data_sig[[i]], prd_sig[[i]], e = e[[i]]))) %>% 
  mutate(obj = map(seq_along(x), function(i) obj_sig[[i]]+obj_0[[i]])) %>% 
  # mutate(pars = list(pars_apap, pars_apap_free_ka, pars_bic_sigma_NA, pars_met_sigma_NA)) %>% 
  mutate(pars = fitted_pars) %>% 
  mutate(observables = list(observables_apap, observables_apap, observables_bic, observables_met),
         errors = list(NULL, NULL, errors_bic_sigma_NA, errors_met_sigma_NA),
         trafo = list(trafo_apap, trafo_apap_free_ka, trafo_bic, trafo_met),
         trafo_sig = list(NULL, NULL, trafo_bic_sigma_NA, trafo_met_sigma_NA))
```


```{r save dMod.frame}
saveRDS(dMod.frame, tpaste0("dMod.frame.rds"))
tpaste0("dMod.frame.rds")
```

Test if the objective functions work
```{r testframe}
testframe <- dMod.frame %>% mutate(test = map(seq_along(x), function(i) {obj[[i]](pars[[i]])}))
```

```{r fit_frame}
fit_frame <- dMod.frame %>% 
  mutate(obj = map(seq_along(x), function(i) obj[[i]] + constraintL2(mu = (names(pars[[i]]) %>% are_names_of(0))))) %>% 
  mutate(hypothesis = paste(hypothesis, "with prior"))

fit_frame <- rbind(dMod.frame, fit_frame)

testframe <- fit_frame %>% mutate(test = map(seq_along(x), function(i) {obj[[i]](pars[[i]])}))
testframe[["test"]] %>% map("value")
```



Try to fit
```{r start fits}
fit_frame <- fit_frame %>% 
  mutate(fits = map(seq_along(x), function(i) {
    assign("fit_obj", obj[[i]], pos = .GlobalEnv)
    assign("fit_pars", pars[[i]], pos = .GlobalEnv)
    assign("fit_studyname", paste0("fits",hypothesis[[i]]), pos = .GlobalEnv)
    mstrust(objfun = fit_obj, center = fit_pars, studyname = fit_studyname, blather = T, cores = 8)
    }))
# fit_frame[["fits"]] %>% str1
saveRDS(testframe, tpaste0("fit_frame.rds"))
tpaste0("fit_frame.rds")
```


# analysis of the fits
```{r analysis_frame}
analysis_frame <-
  fit_frame %>% 
    mutate(parframes = map(fits, as.parframe)) %>% 
    mutate(parvecs = map(parframes, as.parvec)) %>% 
  mutate(prd = map(seq_along(x), function(i) prd_sig[[i]]+prd[[i]]),
         data = map(seq_along(x), function(i) data_sig[[i]]+data[[i]])) %>% 
  mutate(pred = map(seq_along(x), function(i) prd[[i]](times = seq(0, max(as.data.frame(data[[i]])$time),length.out = 100), pars = parvecs[[i]], deriv = F) )) %>% 
  mutate(plot_value = map(parframes, plotValues),
         plot_pars = map(parframes, plotPars),
         plot_combined = map(seq_along(x), function(i) plotCombined(pred[[i]], data[[i]]))) %>% 
  mutate(plot_value = map(seq_along(x), function(i) plot_value[[i]] + ggtitle(label = hypothesis[[i]])),
         plot_pars = map(seq_along(x), function(i) plot_pars[[i]] + ggtitle(label = hypothesis[[i]])),
         plot_combined = map(seq_along(x), function(i) plot_combined[[i]] + ggtitle(label = hypothesis[[i]])))
```

```{r add reduced condition names for plotting, message=FALSE}

analysis_frame <- analysis_frame %>%  mutate(conditions = map(data, names) %>% map(. %>% str_trunc(10))) %>% 
    mutate(
      # plot_value = map(seq_along(x), function(i) plot_value[[i]] + scale_color_dMod(labels = conditions[[i]])),
         # plot_pars = map(seq_along(x), function(i) plot_pars[[i]] + scale_color_dMod(labels = conditions[[i]])),
         plot_combined = map(seq_along(x), function(i) plot_combined[[i]] + scale_color_dMod(labels = conditions[[i]])))

```


```{r}
names(analysis_frame)
```


```{r waterfall plots}
valplots <- analysis_frame$plot_value %>% set_names(analysis_frame$hypothesis)
valplots
```

```{r converged}
map(analysis_frame$parframes, "converged") %>% set_names(analysis_frame$hypothesis)
```

```{r}
analysis_frame$parframes
```


```{r plotpars}
analysis_frame$plot_pars
```

```{r plotcombined}
analysis_frame$plot_combined %>% set_names(analysis_frame$hypothesis) %>% .[[3]] %>% ggplotly()
```





```{r objective functions}
obj_apap <- normL2(data_apap %>% as.datalist, (g_apap*x_apap*p_apap))
obj_apap_free_ka <- normL2(data_apap %>% as.datalist, (g_apap*x_apap*p_apap_free_ka))
obj_bic <- normL2(data_bic %>% as.datalist, (g_bic*x_bic*p_bic))
obj_bic_sigma_NA <- normL2(data_bic_sigma_NA %>% as.datalist, (g_bic*x_bic*p_bic_sigma_NA), errmodel = e_bic_sigma_NA)
obj_met <- normL2(data_met %>% as.datalist, (g_met*x_met*p_met))
obj_met_sigma_NA <- normL2(data_met_sigma_NA %>% as.datalist, (g_met*x_met*p_met_sigma_NA), errmodel = e_met_sigma_NA)
```

Automated calls of the objective functions to see if it works
```{r testing the objfuns}
c("obj_apap", "obj_apap_free_ka", "obj_bic", "obj_met") %>% lapply(function(i) {
  identifier <- str_replace(i, "obj_", "")
  paste0(i, "(pars_", identifier, ")") %>% parse(text=.) %>% eval()
})
```

# To do:
1. Define all other objects necessary to allow automated calls of all objfns, prdfns, ...
  For example, if I have obj_met_all (combination of obj_met and obj_met_sigma_NA), I also need to have parameters which are called pars_met_all.
2. Before fitting, find out, why so many derivatives wrt s0 and srel-pars are zero
3. Run test-fits on the local machine to see if it works before starting lots of useless fits 


Fit the objfuns without the data which doesn't contain sigmas. I uncommented this after running it so it doesn't run again.
```{r fitting the objfuns}
# myjobs <- 
#   ls(pattern = "obj")[c(1,2,3,5)] %>% lapply(function(i) {
#   identifier <- str_replace(i, "obj_", "")
#   # paste0(i, "(pars_", identifier, ")")
#   paste0("runbg(mstrust(", i, ",pars_", identifier, ",sd = 5, fits = 100, cores = 6), machine = 'ruprecht1')")  %>% parse(text=.) %>% eval()
# })
```


## Include data without sigmas
I forgot to include the data without the sigma. Adding the respective objective functions gives me a combined objective function.

```{r adding the respective objfuns together}
obj_met_all <- (obj_met + obj_met_sigma_NA)
obj_bic_all <- (obj_bic + obj_bic_sigma_NA)
```

```{r fitting the added objuns}
# myjobs_all <-
#   c("obj_apap", "obj_apap_free_ka", "obj_bic", "obj_met") %>% lapply(function(i) {
#   identifier <- i %>%  str_replace_all(c("obj_" = "", "_all" = "")) %>% paste0(., "_sigma_NA")
#   # paste0(i, "(pars_", identifier, ")")
#   paste0("runbg(mstrust(", i, ",pars_", identifier, ",sd = 5, fits = 40, cores = 3), machine = c('knecht3', 'knecht4', 'knecht5', 'ruprecht1', 'ruprecht1'))")  %>% parse(text=.) %>% eval()
# })
```

```{r}
save.image(tpaste0("workspace.rda"))
```



# Analyze the fits
The object "all_fits" is saved in the current workspace. It includes all upper six fits, their names are referring to the objective functions that were used in this fit.
```{r}
# all_jobs <- c(myjobs, myjobs_all)
# names(all_jobs) <- c("obj_apap", "obj_apap_free_ka", "obj_bic", "obj_met",  "obj_bic_all", "obj_met_all")

# all_fits <- lapply(all_jobs, function(j) {
#   fits_j <- paste0("j$get()") %>% parse(text = .) %>% eval()
# })

# all_fits <- all_fits %>% lapply(. %>% reduce(.f = c))

# lapply(all_jobs, function(j) {
#   paste0("j$purge()") %>% parse(text = .) %>% eval()
# })

# names(all_fits) <- names(all_fits) %>% str_replace("obj", "")

```


To conveniently call the prediction functions (g_i*x_i*p_i) by giving them names as the other objects.
Instead of (g_apap*x_apap*p_apap), I now have prd_apap
```{r}
identifiers <- names(all_fits) %>% set_names(names(all_fits)) %>% .[1:4]
g_apap_free_ka <- g_apap
x_apap_free_ka <- x_apap
lapply(identifiers, function(identifier) {
  paste0("prd", identifier, " <- (g", identifier, "*x", identifier, "*p", identifier, ")") %>% parse(text = .) %>% eval(envir = .GlobalEnv)
})
```

Automated calling of the prediction functions with the fitted parameters. 
Furthermore, plot the predictions returned by the best parameters.
```{r}
mypreds <- lapply(identifiers, function(identifier) {
  paste0("prd", identifier, "(times, all_fits[['", identifier, "']] %>% as.parframe %>% as.parvec(1), deriv = F )") %>% parse(text = .) %>% eval(envir = .GlobalEnv)
}) %>% set_names(identifiers)


# Plot 
lapply(identifiers, function(identifier) {
  paste0("plotCombined( mypreds[['", identifier, "']], data = data", identifier, " %>% as.datalist(), name %in% names(observables", identifier,"))")  %>% parse(text = .) %>% eval(envir = .GlobalEnv)
})

```

Save the current workspace
```{r}
# "2018_03_09_17_17_workspace.rda"
save.image(tpaste0("workspace.rda"))
tpaste0("workspace.rda")
```






