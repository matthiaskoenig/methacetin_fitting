---
title: "Fitting model 39"
output: 
  html_document:
    toc: TRUE
---


Load all important libraries
```{r setup, message=FALSE, warning=FALSE, eval=TRUE, echo=FALSE}
knitr::opts_chunk$set(eval = FALSE)
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(fig.height = 10)
knitr::opts_chunk$set(fig.width = 15)
library(dMod)
library(stringr) # Um bequem mit strings zu arbeiten
library(tidyverse) # Viele Funktionen, u.a. für data.frames und ggplot2 für schöne plots
library(magrittr) # der Pipe-operator %>%: z.B: x =" a; y="f(x); z="g(y); wird zu z=" a %>% f %>% g
library(conveniencefunctions)



# load("2018_03_09_17_17_workspace.rda")
# for(i in lsdMod(classlist = "prdfn")) {loadDLL(i)}
```


# Read model
```{r}
source("../model/limax_pkpd_39.R")
```

```{r}
pars_raw <- c(x0, p) 
pars_in_dxdtdmod <- c(getSymbols(dxdt_dmod), names(dxdt_dmod))
```

# Odemodels and predicition function

## Apap
```{r odemodel_apap}
free_pars_apap <- c("Ka_apap", "APAPD_HLM_CL", "APAPD_Km_apap")
odemodel_apap <- odemodel(dxdt_dmod, modelname = "odemodel_apap", fixed = setdiff(pars_in_dxdtdmod, c(free_pars_apap, "Aar_apap"))) # Aar_apap is not there to be optimized, but a variable which is a state is needed because of a bug in odemodel.

x_apap <- Xs(odemodel_apap)
```


### Apap_doses
```{r odemodel_apap_doses}
free_pars_apap_doses <- c(free_pars_apap, "PODOSE_apap", "IVDOSE_apap")
odemodel_apap_doses <- odemodel(dxdt_dmod, modelname = "odemodel_apap_doses", fixed = setdiff(pars_in_dxdtdmod, c(free_pars_apap_doses, "Aar_apap"))) # Aar_apap is not there to be optimized, but a variable which is a state is needed because of a bug in odemodel.

x_apap_doses <- Xs(odemodel_apap_doses)
```

## Bicarbonate

```{r odemodel_bic}
free_pars_bic <- c("Ka_co2c13", "KLU_EXCO2", "CO2FIX_HLM_CL", "KBO_FIXCO2", "KBO_RELCO2", "KBO_MAXCO2")
odemodel_bic <- odemodel(dxdt_dmod, modelname = "odemodel_bic", fixed = setdiff(pars_in_dxdtdmod, c(free_pars_bic, "Aar_apap"))) # Aar_apap is not there to be optimized, but a variable which is a state is needed because of a bug in odemodel.

x_bic <- Xs(odemodel_bic)
```

## Metc13

```{r odemodel_met}
free_pars_met <- c("Ka_metc13", "CYP1A2MET_CL", "CYP1A2MET_Km_met")
odemodel_met <- odemodel(dxdt_dmod, modelname = "odemodel_met", fixed = setdiff(pars_in_dxdtdmod, c(free_pars_met, "Aar_apap"))) # Aar_apap is not there to be optimized, but a variable which is a state is needed because of a bug in odemodel.

x_met <- Xs(odemodel_met)
```

## Combined

```{r odemodel_apap_bic_met}
free_pars_apap_bic_met <- c(free_pars_apap_doses, free_pars_bic, free_pars_met) %>% unique
odemodel_apap_bic_met <- odemodel(dxdt_dmod, modelname = "odemodel_apap_bic_met", fixed = setdiff(pars_in_dxdtdmod, c(free_pars_apap_bic_met, "Aar_apap"))) # Aar_apap is not there to be optimized, but a variable which is a state is needed because of a bug in odemodel.

x_apap_bic_met <- Xs(odemodel_apap_bic_met)
```

```{r}

```



# Observation functions

## Apap, Apap_dose

```{r g_apap}
observables_apap <- y_dmod[c("Mve_apap", "DOB")] %>% set_names(c("apap", "dob_apap"))
g_apap <- Y(g = observables_apap, f = x_apap)
```

## Bicarbonate

```{r g_bic}
recovery_bic <- paste(y_dmod["Exhalation_co2c13"], "/ 60 * Mr_co2c13 / Ri_co2c13 * 100")
observables_bic <- c(recovery_bic, y_dmod[c("DOB", "P_CO2Fc13")])
names(observables_bic) <- c("recovery_bic", "dob_bic", "co2_ratio_bic")

observables_bic["co2_ratio_bic"] <- paste0(observables_bic["co2_ratio_bic"], " + offset_bic")

g_bic <- Y(observables_bic, x_bic)
```

## Metc13

```{r g_met}
recovery_met <- paste(y_dmod["Exhalation_co2c13"], "/ init_PODOSE_metc13 * Mr_metc13 * 100" )
cum_met <- paste( "Abreath_co2c13/ init_PODOSE_metc13 * Mr_metc13 * 100")
observables_met <- c(recovery_met, cum_met) %>% set_names(c("recovery_met", "cum_met"))

g_met <- Y(observables_met, x_met)
```

## Combined

```{r g_apap_bic_met}
observables_apap_bic_met <- c(observables_apap, observables_bic, observables_met)
g <- Y(observables_apap_bic_met, x_apap_bic_met)
```



# Data 
Read data, insert the default values for the parameters supplied in the data sheet. 
```{r, message=FALSE}
data <- read_csv("data.csv") %>% as.data.frame
supplied_pars <- names(pars_raw)[(names(pars_raw) %in% names(data))]
data[supplied_pars][is.na(data[supplied_pars])] <- 0
```


# Parameter trafos
## Apap
```{r p_apap}
data_apap <- data %>% 
  filter((IVDOSE_apap!=0)|(PODOSE_apap!=0))
  
outer_pars_apap <- sort(c(supplied_pars, free_pars_apap))

trafo_apap <-
  pars_raw %>% 
  sort_by_name() %>% 
  replace((names(.) %in% outer_pars_apap), outer_pars_apap) %>% 
  
  branch(data_apap %>% as.datalist() %>% covariates()) %>% 
  
  minsert(supplied_pars) %>% 
  
  insert("x~exp(X)", x = free_pars_apap, X = toupper(free_pars_apap)) # backtrafo to linear pars from log-pars

p_apap <- P(trafo_apap)

pars_apap <- log(pars_raw[free_pars_apap]) %>% set_names(toupper(free_pars_apap))
```

### Test plot
```{r plot_apap, eval=TRUE}
# loadDLL(x_apap)
times <- seq(0,24, 0.1)
plotCombined((g_apap*x_apap*p_apap)(times, pars_apap, deriv = F), data = data_apap %>% as.datalist(), name %in% names(observables_apap))
```

## Apap, study-specific aborption rates
```{r trafo apap_free_ka, warning=FALSE}
outer_pars_apap <- sort(c(supplied_pars, free_pars_apap))

trafo_apap_free_ka <-
  pars_raw %>% 
  sort_by_name() %>% 
  replace((names(.) %in% outer_pars_apap), outer_pars_apap) %>% 
  
  branch(data_apap %>% as.datalist() %>% covariates()) %>% 
  
  minsert(supplied_pars) %>% 
  
  insert("x~x_study_group", x = "Ka_apap", study = study, group = group) %>% 
  
  insert("x~exp(X)", 
         x = getSymbols(mytrafo[[i]]), 
         X = toupper(getSymbols(mytrafo[[i]])))  # hacking insert()...



p_apap_free_ka <- P(trafo_apap_free_ka)

pars_apap_free_ka <- getParameters(p_apap_free_ka) %>% are_names_of(0)
```


## Bicarbonate

Some studies don't have sigmas. Estimate the errors for them while fitting. For this, we need to define an error model.
1. Split the data into studies a) with errors "_bic" and b) without errors "_bic_sigma_NA"
2. Define the error model (technically, this will also be an observation function: It "observes" the outputs of the model, e.g. "recovery", and calculates another variable from it, the error)
3. For both sets of data, "_bic", and "bic_sigma_NA", we now need condition specific parameters. Additionally, in "_bic_sigma_NA", we need to supply the parameters of our error model.

### Error model

```{r e_bic}
data_bic <- data %>% 
  filter((IVDOSE_co2c13!=0)|(PODOSE_co2c13!=0)|Ri_co2c13!=0)

studies_with_sigma_na <- data_bic %>% filter(is.na(sigma)) %>% .[["study"]] %>% unique
data_bic_sigma_NA <- data_bic %>% filter(study %in% studies_with_sigma_na)
data_bic <- data_bic %>% filter(! study %in% studies_with_sigma_na)

errors_bic_sigma_NA <- paste0("sqrt(s0_", names(observables_bic), "^2 + srel_", names(observables_bic), "^2 * ", names(observables_bic), "^2 )") %>% set_names(names(observables_bic))

e_bic_sigma_NA <- Y(g = errors_bic_sigma_NA, f= (g_bic))
```

### Parameter trafo
```{r p_bic}
outer_pars_bic <- sort(c(supplied_pars, free_pars_bic))

trafo_bic<-
  c(pars_raw) %>% 
  sort_by_name() %>% 
  replace((names(.) %in% outer_pars_bic), outer_pars_bic) %>% 
  
  branch(data_bic %>% as.datalist() %>% covariates()) %>% # The table of covariates includes dosepar and dose, which are used in the next line
  
  minsert(supplied_pars) %>% 

  insert("x~exp(X)", x = getSymbols(mytrafo[[i]]), X = toupper(getSymbols(mytrafo[[i]]))) %>% 
  
  define("x~x", x = "offset_bic")

p_bic <- P(trafo_bic)

pars_bic <- getParameters(p_bic) %>% are_names_of(0)
```

```{r p_bic_sigma_NA}
pars_errors_bic_sigma_NA <- getSymbols(errors_bic_sigma_NA) %>% str_subset("^s") %>% are_names_of(1)

outer_pars_bic <- sort(c(supplied_pars, free_pars_bic, names(pars_errors_bic_sigma_NA)))

trafo_bic_sigma_NA <-
  c(pars_raw, pars_errors_bic_sigma_NA) %>% 
  sort_by_name() %>% 
  replace((names(.) %in% outer_pars_bic), outer_pars_bic) %>% 
  
  branch(data_bic_sigma_NA %>% as.datalist() %>% covariates()) %>% # The table of covariates includes dosepar and dose, which are used in the next line
  
  minsert(supplied_pars) %>% 
  
  insert("s~s_study", s = names(pars_errors_bic_sigma_NA), study = study) %>% 
  
  insert("x~exp(X)", x = getSymbols(mytrafo[[i]]), X = toupper(getSymbols(mytrafo[[i]]))) %>% 
  
  insert("x~0", x = c("S0_CO2_RATIO_BIC_BARSTOW1990", "S0_RECOVERY_BIC_BARSTOW1990", 
"SREL_CO2_RATIO_BIC_BARSTOW1990", "SREL_RECOVERY_BIC_BARSTOW1990", 
"S0_DOB_BIC_MEINEKE1993", "S0_RECOVERY_BIC_MEINEKE1993", "SREL_DOB_BIC_MEINEKE1993", 
"SREL_RECOVERY_BIC_MEINEKE1993")) %>% 
  
  define("x~x", x = "offset_bic")

p_bic_sigma_NA <- P(trafo_bic_sigma_NA)

pars_bic_sigma_NA <- getParameters(p_bic_sigma_NA) %>% are_names_of(0)

# p_bic_sigma_NA(pars_bic_sigma_NA)
```

### Example plot
```{r}
loadDLL(x_bic)
(g_bic*x_bic*p_bic_sigma_NA)(times*10, pars_bic_sigma_NA, deriv = F) %>%  plotPrediction(name %in% names(observables_bic))
(g_bic*x_bic*p_bic)(times*10, pars_bic, deriv = F) %>%  
  # lapply(. %>% as.tibble)
  plotPrediction(name %in% names(observables_bic))
```


## Metc13

The same game for the data sets without sigmas applies here. Read the description for Bic.

### Error model
```{r e_met}
data_met <- data %>% filter((PODOSE_metc13!=0))

studies_with_sigma_na <- data_met %>% filter(is.na(sigma)) %>% .[["study"]] %>% unique
data_met_sigma_NA <- data_met %>% filter(study %in% studies_with_sigma_na)
data_met <- data_met %>% filter(! study %in% studies_with_sigma_na)

errors_met_sigma_NA <- paste0("sqrt(s0_", names(observables_met), "^2 + srel_", names(observables_met), "^2 * ", names(observables_met), "^2)") %>% set_names(names(observables_met))

e_met_sigma_NA <- Y(g = errors_met_sigma_NA, f= (g_met))
```

### Parameter trafo
```{r p_met}
outer_pars_met <- sort(c(supplied_pars, free_pars_met))

trafo_met<-
  c(pars_raw) %>% 
  sort_by_name() %>% 
  replace((names(.) %in% outer_pars_met), outer_pars_met) %>% 
  
  branch(data_met %>% as.datalist() %>% covariates()) %>%  # The table of covariates includes dosepar and dose, which are used in the next line
  
  minsert(supplied_pars) %>% 

  define("init_PODOSE_metc13~podose", podose = mytrafo[[i]]["PODOSE_metc13"]) %>% # For the observables, I need the initial dose as a fixed parameter which doesn't change. Because the PODOSE_metc13 is also a state, I need to duplicate this parameters
    
  insert("x~exp(X)", x = getSymbols(mytrafo[[i]]), X = toupper(getSymbols(mytrafo[[i]]))) 

p_met <- P(trafo_met)

pars_met <- getParameters(p_met) %>% are_names_of(0)
```


```{r p_met_sigma_NA}
pars_errors_met_sigma_NA <- getSymbols(errors_met_sigma_NA) %>% str_subset("^s") %>%  are_names_of(1)

outer_pars_met <- sort(c(supplied_pars, free_pars_met, names(pars_errors_met_sigma_NA)))

trafo_met_sigma_NA <-
  c(pars_raw, pars_errors_met_sigma_NA) %>% 
  sort_by_name() %>% 
  replace((names(.) %in% outer_pars_met), outer_pars_met) %>% 
  
  branch(data_met_sigma_NA %>% as.datalist() %>% covariates()) %>% # The table of covariates includes dosepar and dose, which are used in the next line
  
  minsert(supplied_pars) %>% 
  
  define("init_PODOSE_metc13~podose", podose = mytrafo[[i]]["PODOSE_metc13"]) %>% # For the observables, I need the initial dose as a fixed parameter which doesn't change. Because the PODOSE_metc13 is also a state, I need to duplicate this parameters
  
  insert("s~s_study", s = names(pars_errors_met_sigma_NA), study = study) %>% 
  
  insert("x~exp(X)", x = getSymbols(mytrafo[[i]]), X = toupper(getSymbols(mytrafo[[i]]))) %>% 
  insert("x~0", x = c("S0_CUM_MET_KRUMBIEGEL1985", "SREL_CUM_MET_KRUMBIEGEL1985"))
  


p_met_sigma_NA <- P(trafo_met_sigma_NA)

pars_met_sigma_NA <- getParameters(p_met_sigma_NA) %>% are_names_of(0)
```

### Example plot
```{r}
loadDLL(x_met)
(g_met*x_met*p_met_sigma_NA)(times*100, pars_met_sigma_NA, deriv = F) %>% plotPrediction(name %in% names(observables_met))
```



```{r initialize dMod.frame }
dMod.frame <- tibble(hypothesis = c("apap", "apap_free_ka", "bic", "met"),
                     x = list(x_apap, x_apap, x_bic, x_met)) %>% 
  add_column( g = list(g_apap, g_apap, g_bic, g_met)) %>% 
  add_column(p = list(p_apap, p_apap_free_ka, p_bic, p_met),
             data = list(data_apap, data_apap, data_bic, data_met),
             p_sig = list(NULL, NULL, p_bic_sigma_NA, p_met_sigma_NA),
             e = list(NULL, NULL, e_bic_sigma_NA, e_met_sigma_NA),
             data_sig = list(NULL, NULL, data_bic_sigma_NA, data_met_sigma_NA)
  )
```



# Fit


```{r read pars from previous fits}
fitted_pars <- readRDS("fitted_pars.rds")
fitted_pars[[3]] <- c(fitted_pars[[3]], "offset_bic" = -0.01)
fitted_pars[[4]]["S0_RECOVERY_MET_KRUMBIEGEL1985"] <- -1
```


```{r transform dMod.frame to create objfuns}
dMod.frame <- dMod.frame %>% 
  mutate(data = map(data, as.datalist),
         data_sig = map(data_sig, as.datalist)) %>% 
  mutate(prd = map(seq_along(x), function(i) cfn(g[[i]], cfn(x[[i]],p[[i]]))),
         prd_sig = map(seq_along(x), function(i) cfn(g[[i]], cfn(x[[i]],p_sig[[i]])))) %>% 
  mutate(obj_0 = map(seq_along(x), function(i) normL2(data[[i]], prd[[i]])),
         obj_sig = map(seq_along(x), function(i) cf_normL2(data = data_sig[[i]], prd_sig[[i]], e = e[[i]]))) %>% 
  mutate(obj = map(seq_along(x), function(i) obj_sig[[i]]+obj_0[[i]])) %>% 
  # mutate(pars = list(pars_apap, pars_apap_free_ka, pars_bic_sigma_NA, pars_met_sigma_NA)) %>% 
  mutate(pars = fitted_pars) %>% 
  mutate(observables = list(observables_apap, observables_apap, observables_bic, observables_met),
         errors = list(NULL, NULL, errors_bic_sigma_NA, errors_met_sigma_NA),
         trafo = list(trafo_apap, trafo_apap_free_ka, trafo_bic, trafo_met),
         trafo_sig = list(NULL, NULL, trafo_bic_sigma_NA, trafo_met_sigma_NA))
```


```{r save dMod.frame}
saveRDS(dMod.frame, tpaste0("dMod.frame.rds"))
save.image(tpaste0("workspace.rda"))
tpaste0("dMod.frame.rds")
```
```{r}
load("2018_03_23_16_59_workspace.rda")





Fit
```{r start fits}
# fit_job <- runbg({dMod.frame %>%
#     mutate(fits = map(seq_along(x), function(i) {
#       assign("fit_obj", obj[[i]], pos = .GlobalEnv)
#       assign("fit_pars", pars[[i]], pos = .GlobalEnv)
#       assign("fit_studyname", paste0("fits", hypothesis[[i]]), pos = .GlobalEnv)
#       mstrust(objfun = fit_obj, center = fit_pars, studyname = fit_studyname, 
#               sd = 3,
#               blather = T, cores = 20, fits = 200)
#     }))
#   }, machine = "fermi", filename = "tmp_test")



saveRDS(fit_job, tpaste0("fit_job.rds"))
save.image(tpaste0("workspace_with_fits.rda"))
tpaste0("fit_frame.rds")
```

```{r}
load("2018_03_23_17_53_workspace_with_fits.rda")

walk(dMod.frame$x, loadDLL)
```

```{r}
# fit_job$check()
# fit_frame <- fit_job$get()$fermi
# fit_job$purge()
# 
# saveRDS(fit_frame, tpaste0("fit_frame.rds"))
# save.image(tpaste0("workspace_with_fit_frame.rda"))
# tpaste0("fit_frame.rds")
# fit_job$purge()
```

```{r}
# fit_frame <- readRDS()
```


# Analysis of the first fits
```{r}
load("2018_03_25_21_06_workspace_with_fit_frame.rda")
walk(dMod.frame$x, loadDLL)
```

```{r analysis_frame, message=FALSE}
analysis_frame <-
  fit_frame %>% 
    mutate(prd = map(seq_along(x), function(i) prd_sig[[i]]+prd[[i]]),
         data = map(seq_along(x), function(i) data_sig[[i]]+data[[i]])) %>% 
    mutate(conditions = map(data, names) %>% map(. %>% str_trunc(10))) %>% 
    dMf_expand_fits() %>% 
  dMf_append_plots(tol = 5)
```

In hypothesis apap: There are good steps, chi^2 = 490
In hypothesis apap_free_ka: There are good steps, but more. chi^2 = 285
In hypothesis bic: There appears to be a good optimum, but in this optimum, many fits didn't converge. chi^2 = 2703 
In hypothesis met: There are no good steps, especially in the beginning. There seems to be plateau at the beginning. chi^2 = 12700
```{r waterfall plots}
valplots <- analysis_frame$plot_value %>% set_names(analysis_frame$hypothesis)
# valplots[[3]] %>% ggplotly()
# valplots
```

```{r print parframes}
analysis_frame$parframes
```

In hypothesis apap: 
  In the optimum, the pars are unique with sensible values. 
  In the second step, Ka_apap goes to infinity and the other parameters are also really high.
In hypothesis apap_free_ka: 
  In the The pars are determined well, except for Baraka and Chiew, where sometimes infinite absoprtion rates happen. 
  In the other conditions, the pars are spread out more and sometimes have different locations.
In hypothesis bic: 
  Across the first 10 steps, the parameters KBO_FIX_CO2 and KBO_RELCO2 appear to be quite big (both have a lot of variance even within their steps)
  s0_co2_ratio_bic_meineke_1993 appears to be near zero. 
In hypothesis met: 
  The pars are spread out over a wide range. 
  S0_CUM_MET_LALAZAR2008 and S0_RECOVERY_MET_LALAZAR2008 can be zero. In other error-pars a lot of variance can be seen as well.
  CYP1A2MET_KM_MET is very small. This basically means that the MM rate is always at Vmax.
```{r plot_pars}
# analysis_frame[1, "parframes"] %>% .[[1]] %>% .[[1]] %>% plotPars 
# analysis_frame[2,"parframes"] %>% .[[1]] %>% .[[1]] %>% .[1:60,] %>%  plotPars(tol = 2) #%>% ggplotly()
# analysis_frame[3,"parframes"] %>% .[[1]] %>% .[[1]] %>% .[1:64,] %>%  plotPars(tol = 2) #%>% ggplotly()
analysis_frame[3,"parframes"] %>% .[[1]] %>% .[[1]] %>% .[1:49,] %>%  plotPars(tol = 1) #%>% ggplotly()
# analysis_frame[4,"parframes"] %>% .[[1]] %>% .[[1]] %>% .[1:64,] %>%  plotPars(tol = 10) #%>% ggplotly()
# analysis_frame[4,"parframes"] %>% .[[1]] %>% .[[1]] %>% .[4:64,] %>%  plotPars(tol = 10) #%>% ggplotly()
# 
# 
# analysis_frame[3,"fits"][[1]][[1]][[20]]
```


In hypothesis apap: The predictions fit alright, but not perfectly. However, this could be taken as it is
In hypothesis apap_free_ka: The predictions fit better than in apap.
In hypothesis bic: 
  co2_ratio_bic, the predictions are always below the data points. However, the time scales fit well
  dob_bic, Barstow is much slower, Irving a bit and Mohr fits nicely. (Is the sigma of mohr much smaller so the predicition is forced thorugh this trajectory? I guess the reason why barstow and Irving are so much slower is that because the kinetics is working in saturation.
  recovery_bic, it doesn't look as if the fit helped anything
In hypothesis met:
  cum_met,  it appears as if the fit doesn't help anything, the krumbiegel data isn't met at all
  recovery_met: Looks alright, but the height of the peak isn't matched.
```{r plot_combined}
plotframe = analysis_frame %>%
  mutate(g_plot = map(g, function(i) {
    force(i)
    controls(i, name = "attach.input") <-  FALSE
    return(i)})) %>%
  mutate(plot_combined = map(seq_along(x), function(i) {
    myplotcombined <- plotCombined
    environment(myplotcombined) <- parent.env(new.env())
    myplotcombined(best_prediction[[i]], data[[i]], name%in%names(observables[[i]]))
                 })) %>%
  mutate(           plot_combined = map(seq_along(x), function(i) plot_combined[[i]] + ggtitle(label = paste(hypothesis[[i]], ",\t", best_value[[i]]))))

plotframe$plot_combined[[3]] %>% plotly::ggplotly()
```



# Profile Likelihoods Part 1

## Start profiles
```{r}
load("2018_03_25_21_06_workspace_with_fit_frame.rda")
walk(dMod.frame$x, loadDLL)
```

```{r start profiles}
# profile_job_frame <- fit_frame %>% 
#     mutate(prd = map(seq_along(x), function(i) prd_sig[[i]]+prd[[i]]),
#          data = map(seq_along(x), function(i) data_sig[[i]]+data[[i]])) %>% 
#     mutate(conditions = map(data, names) %>% map(. %>% str_trunc(10))) %>% 
#     dMf_expand_fits
# 
# profile_job <- runbg({profile_job_frame %>%
#     mutate(profiles = map(seq_along(x), function(i) {
#       assign("profile_obj", obj[[i]], pos = .GlobalEnv)
#       assign("profile_pars", best_parvec[[i]], pos = .GlobalEnv)
#       profile(obj = profile_obj, pars = profile_pars, whichPar = names(profile_pars),
#               stepControl = list(min = 1e-3, limit = 80))
#     }))
#   }, machine = "fermi", filename = "tmp_profiles", input = "profile_job_frame")
# 
# saveRDS(fit_job, tpaste0("profile_job.rds")) #error hrer
# save.image(tpaste0("workspace_with_profile_job.rda"))
# tpaste0("profile_job.rds")

```

```{r}
# load("2018_03_25_22_52_workspace_with_profile_job.rda")
# walk(dMod.frame$x, loadDLL)
# 
# profile_frame <- profile_job$get()$fermi
# saveRDS(profile_frame, tpaste0("profile_frame.rds"))
# save.image(tpaste0("workspace_with_profile_frame.rda"))
# tpaste0("profile_frame.rds")
```

## Look at the profiles

```{r}
load("2018_03_26_13_32_workspace_with_profile_frame.rda")
walk(dMod.frame$x, loadDLL)
```


In hypothesis apap: All pars are identifiable with OK confidence intervals.
In hypothesis apap_free_ka: The pars KA_APAP_BARAKA1990_NA and KA_APAP_CHIEW2010_NA can be infinitely large. In comparison to apap, APAPD_HLM_CL didn't change, whereas APAPD_KM_APAP seems to have gotten a bit bigger in value.
In hypothesis bic: Only the parameters CO2FIX_HLM_CL and KA_CO2C13 were finished, but they don't look informative.
In hypothesis met: No profile was finished.
```{r}
profile_frame <- profile_frame %>% 
  mutate(plot_profile = map(seq_along(x), function(i) {
    if(i==4) return(NULL) 
    plotProfile(profiles[[i]])})) %>% 
  mutate(plot_pars = map(seq_along(x), function(i) {
    if(i==4) return(NULL)
    plot_profile[[i]] + ggtitle(label = paste(hypothesis[[i]], ",\t"))}))


profile_frame$plot_profile

```

# Profile Likelihood Part 2
Since in bic and met, no profile really looked nice, I decided to start new profiles with the error-parameters fixed. 
```{r}
load("2018_03_25_21_06_workspace_with_fit_frame.rda")
walk(dMod.frame$x, loadDLL)
```

```{r}
profile_job_frame <- fit_frame %>% 
    mutate(prd = map(seq_along(x), function(i) prd_sig[[i]]+prd[[i]]),
         data = map(seq_along(x), function(i) data_sig[[i]]+data[[i]])) %>% 
    mutate(conditions = map(data, names) %>% map(. %>% str_trunc(10))) %>% 
    dMf_expand_fits %>% 
  mutate(profile_free = map(best_parvec, . %>% .[!str_detect(names(.),"^S(0|R)")]),
         profile_fixed = map(best_parvec, . %>% .[str_detect(names(.),"^S(0|R)")]))



profile_job <- runbg({profile_job_frame %>%
    mutate(profiles = vector("list", 4L)) 
    profiles <- lapply(seq_along(1:4), function(i) {
      if(i %in% 1:2) {
        return(list(parframe()))
        } else {
      assign("profile_obj", profile_job_frame$obj[[i]], pos = .GlobalEnv)
      assign("profile_pars", profile_job_frame$best_parvec[[i]], pos = .GlobalEnv)
      assign("profile_fixed", profile_job_frame$profile_fixed[[i]], pos = .GlobalEnv)
      assign("profile_free", profile_job_frame$profile_free[[i]], pos = .GlobalEnv)
      return(profile(obj = profile_obj,
              pars = profile_free,
              whichPar = names(profile_free),
              fixed = profile_fixed,
              stepControl = list(min = 1e-3, limit = 80),
              cores = 20))
      }
    })
    profiles
  }, machine = "fermi", filename = "tmp_profiles_fixed", input = "profile_job_frame")

save.image(tpaste0("workspace_with_profiles_with_fixed_pars.rda"))
```






# New Fits
Test two new hypotheses:
  1. Take out Mohr from the Bicarbonate data to see, if Irving and Barstow are met better
  2. Fit Bic and Met together

## Bic, no Mohr
```{r}
load("2018_03_25_21_06_workspace_with_fit_frame.rda")
walk(dMod.frame$x, loadDLL)
```

```{r start fits without mohrs data}
no_mohr <- dMod.frame[3,]
no_mohr[[1]] <- "bic, exclude Mohr from fitting"
no_mohr_job <- runbg({
  
  str_subset_not <- function(vec, pattern) { #too lazy to check it into conveniencefunctions now...
  vec %>% .[!str_detect(.,pattern)]}
  
  no_mohr %>% 
    mutate(fit_conditions = map(obj, . %>% getConditions %>% str_subset_not("Mohr")) ) %>% 
    mutate(fits = map(seq_along(x), function(i) {
      
      assign("fit_obj", obj[[i]], pos = .GlobalEnv)
      assign("fit_pars", pars[[i]], pos = .GlobalEnv)
      assign("fit_studyname", paste0("fits", hypothesis[[i]]), pos = .GlobalEnv)
      assign("glob_fit_conditions", fit_conditions[[i]], pos = .GlobalEnv)
      # glob_fit_conditions
      mstrust(fit_obj, fit_pars, fit_studyname, conditions = glob_fit_conditions,
              fits = 200, cores = 16)
      }))
},
machine = paste0("fermi"), filename = "fit_job_without_Mohr", input = "no_mohr")

saveRDS(no_mohr_job, tpaste0("no_mohr_fit_job.rds"))
```


## Bic and Met together
Use both data sets
```{r}
load("2018_03_25_21_06_workspace_with_fit_frame.rda")
walk(dMod.frame$x, loadDLL)
```

```{r x, g and e bicmet}
free_pars_bicmet <- c(free_pars_bic, free_pars_met)
odemodel_bicmet <- odemodel(dxdt_dmod, modelname = "odemodel_bicmet", fixed = setdiff(pars_in_dxdtdmod, c(free_pars_bicmet, "Aar_apap"))) # Aar_apap is not there to be optimized, but a variable which is a state is needed because of a bug in odemodel.
x_bicmet <- Xs(odemodel_bicmet)

g_bicmet <- Y(c(observables_bic, observables_met), x_bicmet)

e_bicmet <- Y(c(errors_bic_sigma_NA, errors_met_sigma_NA), g_bicmet)
```

```{r data and p bicmet}
data_bicmet <- rbind(data_bic, data_met)
data_bicmet_sigma_NA <- rbind(data_bic_sigma_NA, data_met_sigma_NA)

outer_pars_bic <- sort(c(supplied_pars, free_pars_bic))
outer_pars_bic_sigma_NA <- sort(c(supplied_pars, free_pars_bic, names(pars_errors_bic_sigma_NA)))

outer_pars_met <- sort(c(supplied_pars, free_pars_met))
outer_pars_met_sigma_NA <- sort(c(supplied_pars, free_pars_met, names(pars_errors_met_sigma_NA)))

trafo_bicmet<-
  c(pars_raw) %>% 
  sort_by_name() %>% 
  replace((names(.) %in% unique(c(outer_pars_bic, outer_pars_met))), sort(unique(c(outer_pars_bic, outer_pars_met)))) %>% 
  
  branch(data_bicmet %>% as.datalist() %>% covariates()) %>% # The table of covariates includes dosepar and dose, which are used in the next line
  
  minsert(supplied_pars) %>% 

  define("init_PODOSE_metc13~podose", podose = mytrafo[[i]]["PODOSE_metc13"]) %>% # For the observables, I need the initial dose as a fixed parameter which doesn't change. Because the PODOSE_metc13 is also a state, I need to duplicate this parameters

  insert("x~exp(X)", x = getSymbols(mytrafo[[i]]), X = toupper(getSymbols(mytrafo[[i]]))) %>% 
  
  define("x~x", x = "offset_bic")


trafo_bicmet_sigma_NA <-
  c(pars_raw, pars_errors_bic_sigma_NA, pars_errors_met_sigma_NA) %>% 
  sort_by_name() %>% 
  replace((names(.) %in% unique(c(outer_pars_bic_sigma_NA, outer_pars_met_sigma_NA))), sort(unique(c(outer_pars_bic_sigma_NA, outer_pars_met_sigma_NA)))) %>% 
  
  branch(data_bicmet_sigma_NA %>% as.datalist() %>% covariates()) %>% # The table of covariates includes dosepar and dose, which are used in the next line
  minsert(supplied_pars) %>% 
  #bic
  insert("s~s_study", s = names(pars_errors_bic_sigma_NA), study = unique(data_bic_sigma_NA$study)) %>% 

  #met
  insert("s~s_study", s = names(pars_errors_met_sigma_NA), study = unique(data_met_sigma_NA$study)) %>% 
  define("init_PODOSE_metc13~podose", podose = mytrafo[[i]]["PODOSE_metc13"]) %>% # For the observables, I need the initial dose as a fixed parameter which doesn't change. Because the PODOSE_metc13 is also a state, I need to duplicate this parameters

  insert("x~exp(X)", x = getSymbols(mytrafo[[i]]), X = toupper(getSymbols(mytrafo[[i]]))) %>% 
  
  #bic
  insert("x~0", x = c("S0_CO2_RATIO_BIC_BARSTOW1990", "S0_RECOVERY_BIC_BARSTOW1990", 
"SREL_CO2_RATIO_BIC_BARSTOW1990", "SREL_RECOVERY_BIC_BARSTOW1990", 
"S0_DOB_BIC_MEINEKE1993", "S0_RECOVERY_BIC_MEINEKE1993", "SREL_DOB_BIC_MEINEKE1993", 
"SREL_RECOVERY_BIC_MEINEKE1993")) %>% 
  define("x~x", x = "offset_bic") %>% 
  
  #met
  insert("x~0", x = c("S0_CUM_MET_KRUMBIEGEL1985", "SREL_CUM_MET_KRUMBIEGEL1985"))



p_bicmet <- P(trafo_bicmet)
pars_bicmet <- getParameters(p_bicmet) %>% are_names_of(0)

p_bicmet_sigma_NA <- P(trafo_bicmet_sigma_NA)
pars_bicmet_sigma_NA <- getParameters(p_bicmet_sigma_NA) %>% are_names_of(0)
```

```{r bicmet.frame with derived objects}
names(dMod.frame)
bicmet.frame <- tibble(
  hypothesis = "bicmet",
  x = list(x_bicmet),
  g = list(g_bicmet),
  p = list(p_bicmet),
  data = list(data_bicmet),
  p_sig = list(p_bicmet_sigma_NA),
  e = list(e_bicmet),
  data_sig = list(data_bicmet_sigma_NA)
) %>% 
  mutate(data = map(data, as.datalist),
         data_sig = map(data_sig, as.datalist)) %>% 
  mutate(prd = map(seq_along(x), function(i) cfn(g[[i]], cfn(x[[i]],p[[i]]))),
         prd_sig = map(seq_along(x), function(i) cfn(g[[i]], cfn(x[[i]],p_sig[[i]])))) %>% 
  mutate(obj_0 = map(seq_along(x), function(i) normL2(data[[i]], prd[[i]])),
         obj_sig = map(seq_along(x), function(i) cf_normL2(data = data_sig[[i]], prd_sig[[i]], e = e[[i]]))) %>% 
  mutate(obj = map(seq_along(x), function(i) obj_sig[[i]]+obj_0[[i]])) %>% 
  mutate(pars = list(pars_bicmet_sigma_NA))
  
# bicmet.frame$obj[[1]](bicmet.frame$pars[[1]]) #test works
```



```{r fit bicmet}


# fit_bicmet_job <- runbg({
#   
#   str_subset_not <- function(vec, pattern) { #too lazy to check it into conveniencefunctions now...
#   vec %>% .[!str_detect(.,pattern)]}
#   
#   bicmet.frame %>%
#       mutate(fit_conditions = map(obj, . %>% getConditions %>% str_subset_not("Mohr")) ) %>% 
# 
#     
#     mutate(fits = map(seq_along(x), function(i) {
#       assign("fit_obj", obj[[i]], pos = .GlobalEnv)
#       assign("fit_pars", pars[[i]], pos = .GlobalEnv)
#       assign("fit_studyname", paste0("fits", hypothesis[[i]]), pos = .GlobalEnv)
#       
#      assign("glob_fit_conditions", fit_conditions[[i]], pos = .GlobalEnv)
#      
# 
#       
#       mstrust(objfun = fit_obj, center = fit_pars, studyname = fit_studyname, conditions = glob_fit_conditions,
#               sd = 4, iterlim = 150,
#               blather = T, cores = 9, fits = 54)
#     }))
#   }, machine = c(paste0("knecht", c(2, 4, 5)), paste0("ruprecht", c(1, 1, 2))) ,
#                  filename = tpaste0("fit_bicmet"), input = "bicmet.frame")
# 
# saveRDS(fit_bicmet_job, tpaste0("fit_bicmet_job.rds"))
```

```{r}
mybicmet.frame <- fit_bicmet_job$get()
bicmet_fits <-
  map(mybicmet.frame, function(i) i[["fits"]] %>% .[[1]]) %>% 
    Reduce(f=c.parlist,x=.) 

bicmet.frame$fits <- list(bicmet_fits)
```

```{r}
save.image(tpaste0("workspace_with_bicmet_fits"))
```

```{r}
load("2018_03_27_11_16_workspace_with_bicmet_fits")
walk(bicmet.frame$x, loadDLL)
walk(dMod.frame$x, loadDLL)
```



1. There are no good steps at all, but the lowest values at least have roughly the same parameter values for the kinetic parameters.
2. Apparently, error parameters don't have such a high influence.
3. Interestingly, the chi^2 is better than in met alone. But the chi^2 is worse than in bic alone, so adding bic to met helps but not vice versa
4. the offset-parameter wasnt estimated well
```{r}
plot_bicmet_frame <- bicmet.frame %>% 
  mutate(prd = map(seq_along(x), function(i) prd_sig[[i]]+prd[[i]]),
         data = map(seq_along(x), function(i) data_sig[[i]]+data[[i]])) %>% 
    mutate(conditions = map(data, names) %>% map(. %>% str_trunc(10))) %>% 
  mutate(g = map(g, function(myg) controls(myg, name = "attach.input") <- F)) %>% 
  dMf_expand_fits() %>% 
  mutate(parframes = map(seq_along(x), function(i) parframes[[i]][1:50,])) %>% 
  dMf_append_plots(tol = 10)

plot_bicmet_frame$plot_value

plot_bicmet_frame$plot_pars %>% .[[1]] +
  scale_y_continuous(breaks = (-5:2)*5) + 
  coord_cartesian(ylim = c(-25,10))



plotCombined.dMod.frame(plot_bicmet_frame, index = 2) 


```



```{r}
plotCombined.dMod.frame <- function(plot_bicmet_frame, hypothesis = 1, index = 1, ... ) {
  if(hypothesis %>% is.character) hypothesis <- which(plot_bicmet_frame$hypothesis == hypothesis)
  i <- hypothesis #so i can copy other code
  
  myparvec <- plot_bicmet_frame[i, "parframes"] %>% .[[1]] %>% .[[1]] %>% as.parvec(index = index)
  
  mypred <- plot_bicmet_frame$prd[[i]](times = seq(0, max(as.data.frame(plot_bicmet_frame$data[[i]])$time),length.out = 100),
           pars = myparvec,
           deriv = F)
  
  myvalue <- plot_bicmet_frame[i, "parframes"] %>% .[[1]] %>% .[[1]] %>% .[i, "value"]
  
  plotCombined(mypred,  plot_bicmet_frame$data[[i]], ...) + ggtitle(label = paste(plot_bicmet_frame$hypothesis[[i]], ",\t", myvalue))
  
}
```

### Start LHS around the best 8 steps
Sampling around the optimum a bit denser could help finding some steps
```{r}
load("2018_03_27_11_16_workspace_with_bicmet_fits")
walk(bicmet.frame$x, loadDLL)
walk(dMod.frame$x, loadDLL)
```

```{r}
bicmet.frame %>% select(-contains("plot")) %>% names

offset_bic <- analysis_frame[3,"best_parvec"][[1]][[1]]["offset_bic"]



bicmet.frame2 <- map(1:8, function(i) {
  indices <- myframe$parframes[[1]]$value %>% dMod:::stepDetect(10) #obtained from plotPars(tol)
  
  myframe <- bicmet.frame
  myframe$obj[[1]] <- myframe$obj[[1]] + constraintL2(mu = offset_bic, sigma = 0.01)
  myframe$pars[[1]] <- myframe$parframes[[1]] %>% as.parvec(index = indices[i])
  myframe$hypothesis <- paste("bicmet, refit around step", i)
  
  return(myframe)
  }) %>% do.call(rbind,.)


```

```{r}
fit_bicmet_job <- runbg({

  str_subset_not <- function(vec, pattern) { #too lazy to check it into conveniencefunctions now...
  vec %>% .[!str_detect(.,pattern)]}

  bicmet.frame2 %>%
      mutate(fit_conditions = map(obj, . %>% getConditions %>% str_subset_not("Mohr")) ) %>%

    mutate(fits = map(seq_along(x), function(i) {
      assign("fit_obj", obj[[i]], pos = .GlobalEnv)
      assign("fit_pars", pars[[i]], pos = .GlobalEnv)
      assign("fit_studyname", paste0("fits", hypothesis[[i]]), pos = .GlobalEnv)

     assign("glob_fit_conditions", fit_conditions[[i]], pos = .GlobalEnv)

      mstrust(objfun = fit_obj, center = fit_pars, studyname = fit_studyname, conditions = glob_fit_conditions,
              sd = .7, iterlim = 80,
              blather = T, cores = 8, fits = 8)
    }))
  }, machine = c(paste0("ruprecht", c(1, 1, 1, 2, 2))) ,
                 filename = tpaste0("fit_bicmet2"), input = "bicmet.frame2")

saveRDS(fit_bicmet_job, tpaste0("fit_bicmet_job.rds"))

```

```{r}
myworkspace <- ls()
in_workspace_is_tibble <- map_lgl(myworkspace, . %>% get(pos = .GlobalEnv) %>% class %>% str_detect("tbl") %>% any)

myworkspace[in_workspace_is_tibble]

object_sizes_in_workspace <- map(myworkspace, function(i) pryr::object_size(get(i, pos = .GlobalEnv))/1024/1024) %>% set_names(myworkspace)

save.image()
```



























