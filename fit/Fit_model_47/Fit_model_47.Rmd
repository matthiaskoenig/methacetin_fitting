---
title: "Fitting model 47"
output: 
  html_document:
    toc: TRUE
---


Load all important libraries
```{r setup, message=FALSE, warning=FALSE, eval=TRUE, echo=FALSE}
knitr::opts_chunk$set(eval = TRUE)
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(fig.height = 10)
knitr::opts_chunk$set(fig.width = 15)
# library(stringr) # Um bequem mit strings zu arbeiten
# library(tidyverse) # Viele Funktionen, u.a. für data.frames und ggplot2 für schöne plots
# library(magrittr) # der Pipe-operator %>%: z.B: x =" a; y="f(x); z="g(y); wird zu z=" a %>% f %>% g
library(conveniencefunctions)

# r modifications of plotting functions}
# stepDetect <- dMod:::stepDetect
# plotPars.parframe <- dMod:::plotPars.parframe
# getSteps <- function(myparframe, stepInd = 1, tol = 1) {
#   steps <- steps0 <- stepDetect(myparframe$value, tol)
#   steps0 <- c(steps0, nrow(myparframe))
# 
#   if(!is.null(stepInd)){
#     nsteps <- length(stepInd)
#     steps <- stepInd
#   } else {
#     steps <- steps[order(c(diff(steps), nrow(myparframe)-max(steps)), decreasing = T)][1:nsteps]
#     steps <- unique(sort(c(1, steps))) #include the first step no matter what
#     if(length(steps0) <= nsteps) 
#       nsteps <- length(steps0)
#   }
#   
#   steps <- c(steps, nrow(myparframe))
#   steps_indices <- which(steps0%in%steps)
#   
#   step_members <- lapply(1:nsteps, function(i) {
#     steps0[steps_indices[i]]:(steps0[steps_indices[i]+1]-1)
#   }) 
#   step_members <- do.call(c,step_members)
#   
#   myparframe[step_members,]
# }
# 
# 
# plotPars2 <- function(dMod.frame = model, hypothesis = 1:2,  ..., nsteps = 3, tol = 1, stepInd = NULL ) {
# 
#   if (!missing(...)) {dots <- substitute(...)
#   } else {
#     dots <- T
#   }
# 
#   if(is.character(hypothesis)) hypothesis <- which(dMod.frame$hypothesis == hypothesis)
# 
#   if(length(hypothesis)==1) {
#     myparframe <- dMod.frame[["parframes"]][[hypothesis]]
#     myparframe <- getSteps(myparframe, nsteps = nsteps, tol = tol, stepInd = stepInd)
# 
#     plotPars.parframe(myparframe, ..., tol = tol) +
#       ggtitle(label = paste0(dMod.frame[["hypothesis"]][[hypothesis]], "\n",
#                              "best value = ", round(dMod.frame[["parframes"]][[hypothesis]][1,"value", drop = T],1), "\n",
#                              paste0(paste(names(dots), "=", dots )[-1], collapse = "\n")) )
#   } else {
#     mydata <- do.call(rbind,lapply(hypothesis, function(hyp) {
#       pars <- dMod.frame[["parframes"]][[hyp]]
#       pars <- cbind(index = 1:nrow(pars), pars[order(pars$value),!(names(pars) == "index")])
#       if(!is.null(stepInd)){
#         steps <- stepInd
#       } else {
#         steps <- getStepIndices(pars, nsteps, tol)
#       }
#       pars <- getSteps(pars, tol = tol, stepInd = steps)
#       cbind(hypothesis = hyp, step = factor(findInterval(pars$index, steps), labels = steps), pars)
#     }))
#     mydata$hypothesis <- as.factor(mydata$hypothesis)
# 
#     myindices <- with(mydata, eval(dots))
#     mydata <- mydata[myindices,]
# 
#     mydata2 <- wide2long.data.frame(mydata[-c(4,5,6)], keep = 1:3)
#     mydata2$hyp_step <- paste(mydata2$hypothesis, mydata2$step, sep = "_")
# 
#     ggplot2::ggplot(mydata2, aes(x = name, y = value, color = hyp_step)) +
#       geom_boxplot(outlier.alpha = 0) +     # annotate("text", x = jumps + 1, y = y.jumps, label = jumps, hjust = 0, color = "red", size = 3) +
#       xlab("parameter") + ylab("value") + theme_dMod() +
#       theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
# 
#   }
# 
# }
```


# Read model
```{r read_model, dependson="setup"}
source("../../model/limax_pkpd_v47.R")
pars_raw <- c(x0, p) 
pars_in_dxdtdmod <- c(getSymbols(dxdt_dmod), names(dxdt_dmod))
```


# Data - read and preprocess
Read data, insert the default values for the parameters supplied in the data sheet. 

* Taheri rausschmeißen zum Fitten: Wird weiter unten getan

```{r, message=FALSE}
# Read data
data_full <-
  read_tsv("../../data/limax_pkpd_v47_data.csv") %>%
  select(-model) %>% 
  rename(name = observer) %>% 
  rename(n = subjects) %>% 
  unique() #noch matthias sagen, dass lalazar2008 doppelte einträge hat

# For those studies where some data points have no sigma, infer it from the other sigmas of the same study
fitErrorModel_factors <- c("study", "group", "name", "BW", "PODOSE_apap", "IVDOSE_apap", 
"PODOSE_co2c13", "IVDOSE_co2c13", "Ri_co2c13", "ti_co2c13", "PODOSE_metc13", 
"IVDOSE_metc13", "ti_metc13")
some_na <-
  data_full %>% 
  group_by(study, group, name) %>% 
  mutate(nna = n(), sna = sum(is.na(sigma))) %>% 
  filter(sna>0 & sna != nna) %>% 
  select(-sna, -nna) %>% 
  as.data.frame() %>% 
  fitErrorModel(factors = fitErrorModel_factors, plotting = F, blather = F) 

none_or_all_na <- data_full %>% 
  group_by(study, group, name) %>% 
  mutate(nna = n(), sna = sum(is.na(sigma))) %>% 
  filter(sna==0 | sna == nna) %>% 
  select(-sna, -nna) %>% 
  as.data.frame()

data_full <- rbind(some_na, none_or_all_na) %>% 
  select(-n)
```

# Set up the model

```{r setup model independently of the individual setups}
free_pars <- c("Kp_co2c13", "KBO_MAX_CO2", "KBO_REL_CO2", "KBO_FIX_CO2", "KLI_MAX_CO2", "KLI_REL_CO2", "KLI_FIX_CO2", "KLU_EX_CO2", "KLU_EXKM_CO2", "Ka_co2c13", "Ka_metc13", "APAPD_HLM_CL", "APAPD_Km_apap", "Ka_apap")

# Observables
observables_apap <- y_dmod[c("Mve_apap")] %>% set_names(c("Mve_apap"))

recovery_bic <- paste(y_dmod["Exhalation_co2c13"], "/ 60 * Mr_co2c13 / Ri_co2c13 * 100")
P_CO2F <- paste0(y_dmod["P_CO2Fc13"], "-", str_replace(y_dmod["P_CO2Fc13"], "Alu_co2c13", "0")) # Alu_co2c13 is the only dynamic variable which goes into the equation and it's initial value is fixed to zero.
observables_bic <- c(cum_rec_co2c13 = recovery_bic, y_dmod[c("DOB")], P_CO2F = P_CO2F)

recovery_met <- paste(y_dmod["Exhalation_co2c13"], "/ init_PODOSE_metc13 * Mr_metc13 * 100" )
cum_met <- paste( "Abreath_co2c13/ init_PODOSE_metc13 * Mr_metc13 * 100")
observables_met <- c(recovery_met, cum_met) %>% set_names(c("mom_rec_metc13", "cum_rec_metc13"))

# Error models
errors_bic_sigma_NA <- paste0("sqrt(s0_", names(observables_bic), "^2 + srel_", names(observables_bic), "^2 * ", names(observables_bic), "^2 )") %>% set_names(names(observables_bic))
errors_bic_sigma_NA["cum_rec_co2c13"] <- 1 #hierfür gibts eh keine daten und ich weiß nicht, ob ich es einfach weglassen kann

errors_met_sigma_NA <- paste0("sqrt(s0_", names(observables_met), "^2 + srel_", names(observables_met), "^2 * ", names(observables_met), "^2)") %>% set_names(names(observables_met))
errors_met_sigma_NA["mom_rec_metc13"] <- 1 #hierfür gibts eh keine daten mit sigma=NA
```

```{r x g and e apapbicmet}
myodemodel <- odemodel(dxdt_dmod, fixed = setdiff(pars_in_dxdtdmod, c(free_pars, "Aar_apap")), modelname = "x", compile = F) # Aar_apap is not there to be optimized, but a variable which is a state is needed because of a bug in odemodel.
x <- Xs(myodemodel)

g <- Y(c(observables_apap, observables_bic, observables_met), x, attach.input = F, modelname = "g", compile = F)

e_sigma_NA <- Y(c(errors_bic_sigma_NA, errors_met_sigma_NA), g)#, modelname = "e", compile = F) #cant cope with NaNs passed to it, if compiled
```



```{r data and p apapbicmet}
# Remove certain studies from the data which goes into fitting
data_for_fitting <- data_full %>% 
  filter(!str_detect(simulation, "limax")) %>% 
  filter(!str_detect(study, "Mohr2018")) %>% 
  filter(!(str_detect(study, "Albert")&str_detect(group, "capsule")))

# Split the data in datasets with and without sigma
data <- data_for_fitting  %>% filter(!is.na(sigma)) %>% select(-simulation)
data_sigma_NA <- data_for_fitting  %>% filter(is.na(sigma)) %>% select(-simulation)

# Get all parameters that in some way replace pars_raw (parameters supplied by the SBML file) or are additional parameters that we need to fit
# This could be e.g. Study specific pars such as IVDOSE* or pars that are fitted
supplied_pars <- names(pars_raw)[(names(pars_raw) %in% names(data))]
outer_pars <- sort(unique(c(free_pars, supplied_pars)))

pars_errors <- c(errors_bic_sigma_NA, errors_met_sigma_NA) %>% 
  getSymbols %>% 
  str_subset("^s") %>% 
  are_names_of(1)
outer_pars_sigma_NA <- sort(unique(c(outer_pars, names(pars_errors))))

# Define the parameter trafos which in turn define the different conditions
trafo <-
  c(pars_raw) %>% 
  sort_by_name() %>% 
  replace(names(.) %in% outer_pars, outer_pars) %>% 
  
  branch(data %>% as.datalist() %>% covariates()) %>% # The table of covariates includes dosepar and dose, which are used in the next line
# {.} %T>% {debug(repar)} %>%
# map(getSymbols)
  
insert("name ~ value", value = unlist(mget(supplied_pars)), name = supplied_pars) %>% # insert parameters supplied by the data

  define("init_PODOSE_metc13~podose", podose = mytrafo[[i]]["PODOSE_metc13"]) %>% # For the observables, I need the initial dose as a fixed parameter which doesn't change. Because the PODOSE_metc13 is also a state, I need to duplicate this parameters
  
  insert("x~exp(X)", x = .currentSymbols, X = toupper(.currentSymbols)) %>% 
  {.}


trafo_sigma_NA <-
  c(pars_raw, pars_errors) %>% 
  sort_by_name() %>% 
  replace(names(.) %in% outer_pars_sigma_NA, outer_pars_sigma_NA) %>%
  
  branch(data_sigma_NA %>% as.datalist() %>% covariates()) %>% # The table of covariates includes dosepar and dose, which are used in the next line
  insert("name ~ value", value = unlist(mget(supplied_pars)), name = supplied_pars) %>%

  define("init_PODOSE_metc13~podose", podose = mytrafo[[i]]["PODOSE_metc13"]) %>% # For the observables, I need the initial dose as a fixed parameter which doesn't change. Because the PODOSE_metc13 is also a state, I need to duplicate this parameters
  
  insert("x~exp(X)", x = .currentSymbols, X = toupper(.currentSymbols)) %>% 
  
  insert("x~-11", x = str_subset(.currentSymbols, "^S0"), conditionMatch = "Meineke1993") %>% # Fix the error parameters to a value
  insert("x~0", x = str_subset(.currentSymbols, "^S0"), conditionMatch = "(Barstow)") %>% 
  insert("x~-3", x = str_subset(.currentSymbols, "^SREL"), conditionMatch = "(Barstow)|(Meineke)") %>% 
  
  insert("x~0", x = str_subset(.currentSymbols, "S((0)|(REL))_((DOB)|(P_CO2F))")) %>% 
  insert("x~-4", x = str_subset(.currentSymbols, "S((0)|(REL))"), conditionMatch = "Krumbiegel") %>% 
  {.}


p <- P(trafo, modelname = "p", compile = F)
pars <- getParameters(p) %>% are_names_of(0)

p_sigma_NA <- P(trafo_sigma_NA, modelname = "p_sig", compile = F)
pars_sigma_NA <- getParameters(p_sigma_NA) %>% are_names_of(0)

# Alternative hypothesis:
# Co2 pool 2 being zero
# trafo_co2_0 <- trafo %>% 
#   define("x~0", x = str_subset(.currentSymbols, c("KLI_REL_CO2", "KLI_FIX_CO2")))
# trafo_sigma_NA_co2_0 <- trafo_sigma_NA %>% 
#   define("x~0", x = str_subset(.currentSymbols, c("KLI_REL_CO2", "KLI_FIX_CO2")))
# 
# p_co2_0 <- P(trafo_co2_0, modelname = "p_co2_0")
# p_sigma_NA_co2_0 <- P(trafo_sigma_NA_co2_0, modelname = "p_sigma_NA_co2_0")

compile(g,x, p, p_sigma_NA, cores = 3, output = "gxp")
remove_c_and_o()
```

```{r}
# save.image("workspace.rda")
load("workspace.rda"); loadDLL(x)
```


# dMod.frame
```{r initialize dMod_frame}
model <- dMod.frame(
  hypothesis = "Model v47",
  x = x,
  g = g,
  p = p,
  data = data,
  e = NULL,
  x_sig = x,
  g_sig = g,
  p_sig = list(p_sigma_NA),
  e_sig = list(e_sigma_NA),
  data_sig = list(as.datalist(data_sigma_NA))
)


model <- model %>% 
  rowwise() %>% 
  appendObj() %>% 
  mutate(prd_sig = list(g_sig * x_sig * p_sig), 
         obj_data_sig = list(normL2(data_sig, prd_sig, e_sig)),
         pars = list(union(getParameters(p), getParameters(p_sig)) %>% are_names_of(rnorm)),
         obj = list(obj_data+ obj_data_sig),
         times = list(seq(min(rbind(as.data.frame(data),as.data.frame(data_sig))[["time"]]), 
                          max(rbind(as.data.frame(data),as.data.frame(data_sig))[["time"]]) * 1.1, 
                          length.out = 200))) %>% 
  mutate(prd_data = list(prd),
         prd = list(prd_data+prd_sig), 
         data_data = list(data),
         data = list(data_data + data_sig),
         description = "Model v47")


```

```{r}
# saveRDS(model, "model0.rds")
model <-  readDMod.frame("model0.rds")
```

```{r test model, eval=FALSE}
# hypothesis = 1
test_dMod.frame <- function(model, hypothesis = 1, ...){
  print(plotCombined(model,hypothesis))
  print(with(unlist(model[hypothesis,], F), {
    obj(times, pars = pars)
  }))
}
test_dMod.frame(model,1)
model$pars[[1]] %>% `[<-`(., 1:length(.), 10) %>%  print_r.named_vector()
```

# Fitting
```{r}
fit_47_job <- runbg({
    ncores <- detectFreeCores()
    assign("ncores", ncores, pos = .GlobalEnv)

   model %>%
    ungroup %>%
    mutate(fits = map(seq_along(x), function(i) {
      assign("fit_obj", obj[[i]], pos = .GlobalEnv)
      assign("fit_pars", pars[[i]], pos = .GlobalEnv)
      assign("fit_fixed", NULL, pos = .GlobalEnv)
      # assign("fit_fixed", fixed[[i]], pos = .GlobalEnv)
      assign("fit_studyname", paste0("fits", hypothesis[[i]]), pos = .GlobalEnv)
      mstrust(objfun = fit_obj, 
              center = 0*fit_pars, 
              fixed = fit_fixed, 
              studyname = fit_studyname, 
              sd = 4,
              blather = F, 
              cores = ncores, 
              fits = 30*ncores,
              iterlim = 200,
              parlower = c(
                APAPD_HLM_CL 	=	-8	, # 1
                APAPD_KM_APAP	=	-8	, # 2
                KA_APAP      	=	-8	, # 3
                KA_CO2C13    	=	-8	, # 4
                KA_METC13    	=	-8	, # 5
                KBO_FIX_CO2  	=	-8	, # 6
                KBO_MAX_CO2  	=	-8	, # 7
                KBO_REL_CO2  	=	-8	, # 8
                KLI_FIX_CO2  	=	-8	, # 9
                KLI_MAX_CO2  	=	-8	, # 10
                KLI_REL_CO2  	=	-8	, # 11
                KLU_EX_CO2   	=	-8	, # 12
                KLU_EXKM_CO2 	=	-8	, # 13
                KP_CO2C13    	=	-8	  # 14 
              ), 
              parupper = c(
                APAPD_HLM_CL 	=	10	, # 1
                APAPD_KM_APAP	=	10	, # 2
                KA_APAP      	=	10	, # 3
                KA_CO2C13    	=	10	, # 4
                KA_METC13    	=	10	, # 5
                KBO_FIX_CO2  	=	10	, # 6
                KBO_MAX_CO2  	=	10	, # 7
                KBO_REL_CO2  	=	10	, # 8
                KLI_FIX_CO2  	=	10	, # 9
                KLI_MAX_CO2  	=	10	, # 10
                KLI_REL_CO2  	=	10	, # 11
                KLU_EX_CO2   	=	10	, # 12
                KLU_EXKM_CO2 	=	10	, # 13
                KP_CO2C13    	=	10	  # 14 
              )
      ) })) %>%
    rowwise
}, machine = c(paste0("knecht", c(1,2)), paste0("ruprecht", 1:2), "fermi"), input = "model", filename = "2018_08_06_20_36_fit_47_job"
  # , recover = T
)
# fit_47_job$check()
# fit_47 <- fit_47_job$get()
# fit_47 %>% str1
# fit_47 <- fit_47[-2] %>% uniteFits %>% appendParframes
# saveRDS(fit_47, file = "fit_47.rds")
# model <- readDMod.frame("fit_47.rds")
# fit_47_job$purge()
```

```{r}
parframes_summary(model)
```


# Plotting

```{r plotting helpers}
observables <- model$g[[1]] %>% getEquations() %>%.[[1]] %>%  names

observables_apap <- "Mve_apap"
observables_bic <- c("cum_rec_co2c13", "DOB","P_CO2F")
observables_met <- c("mom_rec_metc13", "cum_rec_metc13")

conditions <- model$obj[[1]] %>% getConditions()
data <- model$data[[1]] %>% as.data.frame()

cond_apap <- data %>% filter(name%in%"Mve_apap") %>% .[["condition"]] %>% unique %>% as.character()
cond_bic <- data %>% filter(name%in%c("cum_rec_co2c13", "DOB","P_CO2F")) %>% .[["condition"]] %>% unique %>% as.character()
cond_met <- data %>% filter(name%in%c("mom_rec_metc13", "cum_rec_metc13")) %>% .[["condition"]] %>% unique %>% as.character()


```

```{r plot predictions}
# Group conditions by observables
which_hypotheses <- c(1:2)
pdf(file = "plots.pdf", width = 16, height = 9)
map(which_hypotheses, function(i) {
  plotCombined(model, i, 1, condition %in% cond_apap & name %in% observables_apap)
})

map(which_hypotheses, function(i) {
  plotCombined(model, i, 1, condition %in% cond_bic & name %in% observables_bic)
})

map(which_hypotheses, function(i) {
  plotCombined(model, i, 1, condition %in% cond_met & name %in% observables_met)
})
dev.off()
```

```{r plot conditions individually}
# Plot conditions individually
pdf(file = "plots_individual.pdf", width = 16, height = 9)
which_hypotheses <- c(1:2)
map(which_hypotheses, function(i) {
  cat(i, "\n")
  map(conditions, function(cond) {
    cat(cond, "\n")
    myobs <- case_when(cond%in%cond_apap ~ list(observables_apap),
                       cond%in%cond_bic  ~ list(observables_bic),
                       cond%in%cond_met  ~ list(observables_met)) %>% unlist
    assign("cond", cond, pos = .GlobalEnv)
    assign("myobs", myobs, pos = .GlobalEnv)
    
    plotCombined(model, i, 1, eval(parse(text = deparse(substitute(condition %in% cond & name %in% myobs))))
                 )
  })
})
dev.off()
```

```{r plot waterfalls}
pdf("waterfalls.pdf")
which_hypotheses <- c(1:2)
mysummary <- parframes_summary(model)
map(which_hypotheses, function(i) {
  cat(i, "\n")
  plotValues(model, i, value < mysummary[[i]]$values["1st Qu."]) %>% print
  plotValues(model, i, value < mysummary[[i]]$values["Median"]) %>% print
  plotValues(model, i, value < mysummary[[i]]$values["3rd Qu."]) %>% print
  plotValues(model, i) %>% print
  plotPars(model, i, tol = 1, nsteps = 3) %>% print
  return(NULL)
})
dev.off()
```

```{r plot Profiles}
pdf("profiles.pdf")
which_hypotheses <- c(1:2)
mysummary <- parframes_summary(model)
map(which_hypotheses, function(i) {
  profplot <- model$profiles[[i]] %>% 
    plotProfile() +
    coord_cartesian(ylim = c(-1,4))
  print(profplot)
  NULL
})
dev.off()
```

```{r plot Profile paths}
pdf("profile paths.pdf")
which_hypotheses <- c(1:2)
mysummary <- parframes_summary(model)
map(which_hypotheses, function(wh) {
  myproflist <- model$profiles[[wh]]
  map(myproflist, function(prof_step) {
    which_pars <- prof_step[["whichPar"]] %>% unique() %>% str_subset_not("KBO_FIX_CO2")
    map(which_pars, function(wp) {
      myplot <- plotPaths(list(prof_step), whichPar = wp, relative = F) + ggtitle(paste0("x-axis: ", wp))
      print(myplot)
      NULL
    })
  })
  NULL
})
dev.off()
```

# Write parameters
```{r}

# Write parameters to pars.csv
pars_hyp1 <- model$parframes[[1]] %>% as.parvec

# uncapitalize_parnames and transform to linear scale
inner_parameters <- model[1,"x"][[1]][[1]] %>% getParameters() %>% sort
indices <- toupper(inner_parameters) %in% names(pars_hyp1) 
uncapitalized_names <- inner_parameters[indices] %>% sort
pars_hyp1 <- pars_hyp1 %>% sort_by_name() %>% setNames(uncapitalized_names) %>% exp

tibble(parname = names(pars_hyp1), parvalue = pars_hyp1) %>% write_csv("pars.csv")
```







